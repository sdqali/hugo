<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Java on Sadique Ali</title>
    <link>http://sdqali.in/categories/java/</link>
    <description>Recent content in Java on Sadique Ali</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Fri, 29 Jan 2016 17:41:49 -0800</lastBuildDate>
    <atom:link href="http://sdqali.in/categories/java/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Using custom arguments in Spring MVC controllers</title>
      <link>http://sdqali.in/blog/2016/01/29/using-custom-arguments-in-spring-mvc-controllers/</link>
      <pubDate>Fri, 29 Jan 2016 17:41:49 -0800</pubDate>
      
      <guid>http://sdqali.in/blog/2016/01/29/using-custom-arguments-in-spring-mvc-controllers/</guid>
      <description>

&lt;p&gt;Most of the Spring controllers in the real world accept a lot of different types of parameters - Path variables, URL parameters, request headers, request body and sometimes even the entire HTTP Request object. This provides a flexible mechanism to create APIs. Spring is really good at parsing these parameters in to Java types as long as there is an ObjectMapper (like Jackson) configured to take care of the de-serialization.&lt;/p&gt;

&lt;p&gt;However, there are situations where you want methods to receive a parameter of a particular type that has to resolved from a set of parameters–for example, an API can expect consumers to send meta data about a request in the form of headers and need a custom type to hold this information. Spring provides a convenient way to provide such custom arguments. This blog post explores this feature and how to implement it and test it.&lt;/p&gt;

&lt;h2 id=&#34;argument-resolvers:9aea8f8b4af2f94f2baa143b388c0ef4&#34;&gt;Argument Resolvers&lt;/h2&gt;

&lt;p&gt;Spring uses argument resolvers to determine how to parse a particular argument required by a controller method from HTTP request body, the URL, URL parameters and HTTP headers. For example when a method expects a request header as in the following example, Spring uses a particular resolver named &lt;code&gt;RequestHeaderMethodArgumentResolver&lt;/code&gt; to resolve this argument. All argument resolvers implement the &lt;code&gt;HandlerMethodArgumentResolver&lt;/code&gt; interface whose contract is:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public interface HandlerMethodArgumentResolver {
    boolean supportsParameter(MethodParameter parameter);
    Object resolveArgument(MethodParameter parameter, ModelAndViewContainer mavContainer,
            NativeWebRequest webRequest, WebDataBinderFactory binderFactory) throws Exception;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;supportsParameter&lt;/code&gt; method determines if this resolver is capable of parsing a given parameter and &lt;code&gt;resolveArgument&lt;/code&gt; specifies how it‘s value should be computed. Notice how this method has the web &lt;code&gt;NativeWebRequest&lt;/code&gt; argument passed to it to allow the look up of request parameters like body, url and headers.&lt;/p&gt;

&lt;p&gt;For this example, the MetaData that we are interested in can be represented as a type:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class MetaData {
    @JsonProperty(&amp;quot;data&amp;quot;)
    private Map&amp;lt;String, String&amp;gt; map  = new HashMap&amp;lt;&amp;gt;();

    private MetaData() {
    }

    public MetaData(Map&amp;lt;String, String&amp;gt; map) {
        this.map = map;
    }

    public String get(String key) {
        return map.get(key);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;An argument resolver to compute this from the incoming request can be written as follows:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class MetaDataResolver implements HandlerMethodArgumentResolver {
    private static final String TRANSACTION_ID = &amp;quot;TRANSACTION-ID&amp;quot;;
    private static final String ACCESS_KEY = &amp;quot;ACCESS-KEY&amp;quot;;
    private List&amp;lt;String&amp;gt; metaDataHeaderNames = Arrays.asList(TRANSACTION_ID, ACCESS_KEY);

    @Override
    public boolean supportsParameter(MethodParameter parameter) {
        return parameter.getParameterType().equals(MetaData.class);
    }

    @Override
    public Object resolveArgument(MethodParameter parameter, ModelAndViewContainer mavContainer, NativeWebRequest webRequest, WebDataBinderFactory binderFactory) throws Exception {
        HashMap&amp;lt;String, String&amp;gt; map = new HashMap&amp;lt;&amp;gt;();
        metaDataHeaderNames.forEach(name -&amp;gt; {
            if (webRequest.getHeader(name) != null) {
                map.put(name, webRequest.getHeader(name));
            }
        });
        return new MetaData(map);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This resolver will try and compute the value for the argument if the arguments type is &lt;code&gt;MetaData&lt;/code&gt;. It computes it by extracting all the headers representing the meta data from the request.&lt;/p&gt;

&lt;h2 id=&#34;using-in-a-controller-method:9aea8f8b4af2f94f2baa143b388c0ef4&#34;&gt;Using in a controller method&lt;/h2&gt;

&lt;p&gt;This parameter can be accessed in a controller method as follows:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@RestController
@RequestMapping(&amp;quot;/profiles&amp;quot;)
public class ProfileController {
    @Autowired
    ProfileService profileService;

    @RequestMapping(path = &amp;quot;/&amp;quot;,
    method = RequestMethod.POST)
    public Map&amp;lt;String, String&amp;gt; create(@RequestBody Profile profile, MetaData metaData) {
        profileService.create(profile, metaData);
        System.out.printf(metaData.toString());
        return Collections.singletonMap(&amp;quot;message&amp;quot;, &amp;quot;success&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If we were to run this app and make a request with the following headers, we will see that the MetaData instance did not get constructed with the right parameters.&lt;/p&gt;

&lt;h2 id=&#34;wiring-up-the-custom-resolver:9aea8f8b4af2f94f2baa143b388c0ef4&#34;&gt;Wiring up the custom resolver&lt;/h2&gt;

&lt;p&gt;For this resolver to work, it needs to be added to the chain of resolvers that Spring uses. This can be done by extending &lt;code&gt;WebMvcConfigurerAdapter&lt;/code&gt;‘s &lt;code&gt;addArgumentResolvers&lt;/code&gt; method as follows:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Configuration
public class Config extends WebMvcConfigurerAdapter {
    @Override
    public void addArgumentResolvers(List&amp;lt;HandlerMethodArgumentResolver&amp;gt; argumentResolvers) {
        argumentResolvers.add(new MetaDataResolver());
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;testing-using-mockmvc:9aea8f8b4af2f94f2baa143b388c0ef4&#34;&gt;Testing using MockMvc&lt;/h2&gt;

&lt;p&gt;In order to test the behavior of a controller in the presence of a custom argument resolver using MockMvc, the resolver need to be added to the list of resolvers that MockMvc is going to use.
 An example test for the above class is as follows:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@RunWith(MockitoJUnitRunner.class)
public class ProfileControllerTest extends TestCase {

    private ProfileController profileController;
    private MockMvc mockMvc;
    private ObjectMapper objectMapper;

    @Mock
    private ProfileService profileService;

    @Before
    public void setUp() {
        objectMapper = new ObjectMapper();
        profileController = new ProfileController(profileService);
        mockMvc = MockMvcBuilders
                .standaloneSetup(profileController)
                .setCustomArgumentResolvers(new MetaDataResolver())
                .build();
    }

    @Test
    public void shouldCreateAProfile() throws Exception {
        Profile profile = new Profile(&amp;quot;foo&amp;quot;, &amp;quot;foo@bar.com&amp;quot;);
        MetaData metaData = new MetaData(Collections.singletonMap(&amp;quot;TRANSACTION-ID&amp;quot;, &amp;quot;foo&amp;quot;));

        mockMvc.perform(post(&amp;quot;/profiles/&amp;quot;)
                .content(objectMapper.writeValueAsBytes(profile))
                .contentType(MediaType.APPLICATION_JSON)
                .header(&amp;quot;TRANSACTION-ID&amp;quot;, &amp;quot;foo&amp;quot;))
                .andExpect(status().isOk());
        Mockito.verify(profileService).create(eq(profile), eq(metaData));
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This test is self-explanatory–we wire up the argument resolver, make a request with one of the meta data headers and expect the profile service to be invoked with the right parameters.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Authentication for Apache Camel HTTP components</title>
      <link>http://sdqali.in/blog/2015/12/16/authentication-for-apache-camel-http-components/</link>
      <pubDate>Wed, 16 Dec 2015 01:07:01 -0500</pubDate>
      
      <guid>http://sdqali.in/blog/2015/12/16/authentication-for-apache-camel-http-components/</guid>
      <description>

&lt;p&gt;My team at work has been lately working on a data transformer that pushes information from an external system in to platform. For historical reasons the information is passed to us in the form of flat files. We have been working on a data transformer that reads information from the file and posts it into an HTTP end point.
Apache Camel &lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:be2633b2f8769813832c8d38507c50a1:1&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:be2633b2f8769813832c8d38507c50a1:1&#34;&gt;1&lt;/a&gt;&lt;/sup&gt; makes a natural choice as the base for implementing such a data transformer. The presence of ready to use components that can read files and post information to HTTP end points and the availability of a nice D.S.L. &lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:be2633b2f8769813832c8d38507c50a1:2&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:be2633b2f8769813832c8d38507c50a1:2&#34;&gt;2&lt;/a&gt;&lt;/sup&gt; makes implementation easy and straightforward. One of the things we had to spend time figuring out was how to ensure that we authenticate correctly against our target HTTP end point. This blog post takes a look at various methods we explored.&lt;/p&gt;

&lt;p&gt;Camel&amp;rsquo;s HTTP component allows http resources to be added as Camel end points. These end points can be consuming information from routes or producing information which are then passed on to routes. For example, the following route takes information from the &lt;code&gt;direct:start&lt;/code&gt; end point, tokenizes it into lines and sends each line into an HTTP url.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class FileToApiRoute extends RouteBuilder {

    public static final String UTF_8 = &amp;quot;UTF-8&amp;quot;;
    public static final String CONTENT_TYPE = &amp;quot;Content-Type&amp;quot;;
    public static final String APPLICATION_JSON = &amp;quot;application/json&amp;quot;;
    public static final String TARGET = &amp;quot;http://localhost:8080/ingest&amp;quot;;

    @Override
    public void configure() throws Exception {
        from(&amp;quot;direct:start&amp;quot;)
                .marshal()
                .string(UTF_8)
                .split(body().tokenize())
                .streaming()
                .setHeader(CONTENT_TYPE, simple(APPLICATION_JSON))
                .to(TARGET);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Once this route has been registered, it can be used to send data by placing information on the &lt;code&gt;direct:start&lt;/code&gt; end point. The following service does it by passing the contents of a file to a &lt;code&gt;ProducerTemplate&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class DataStreamService {

    private final ProducerTemplate producerTemplate;

    @Autowired
    public DataStreamService(ProducerTemplate producerTemplate) {
        this.producerTemplate = producerTemplate;
    }

    public void stream() {
        producerTemplate.sendBody(&amp;quot;direct:start&amp;quot;,
                ExchangePattern.InOnly,
                new File(&amp;quot;src/main/resources/yelp.business.json&amp;quot;));
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Our challenge is to ensure that this continue to work when the HTTP end point in question requires authentication. For the purposes of this blog post, we will be restricting our discussion to Basic Authentication. There are three ways to do this authentication–through Camel authentication query parameters, through the use of the &lt;code&gt;Authorization&lt;/code&gt; header and by overriding the &lt;code&gt;HttpConfiguration&lt;/code&gt; in the current Camel context.&lt;/p&gt;

&lt;h3 id=&#34;camel-authentication-query-parameters:be2633b2f8769813832c8d38507c50a1&#34;&gt;Camel authentication query parameters&lt;/h3&gt;

&lt;p&gt;Camel allows consumers to specify authentication parameters in the http end point. For example, three parameters required for Basic Authentication are &lt;code&gt;authMethod&lt;/code&gt;, &lt;code&gt;authUsername&lt;/code&gt; and &lt;code&gt;authPassword&lt;/code&gt;. The route rewritten with these parameters will be as follows:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;    public static final String TARGET_WITH_AUTH = &amp;quot;http://localhost:8080/ingest&amp;quot; +
            &amp;quot;?authMethod=Basic&amp;amp;authUsername=test&amp;amp;authPassword=test&amp;quot;;

    @Override
    public void configure() throws Exception {
        from(&amp;quot;direct:start&amp;quot;)
                .marshal()
                .string(UTF_8)
                .split(body().tokenize())
                .streaming()
                .setHeader(CONTENT_TYPE, simple(APPLICATION_JSON))
                .to(TARGET_WITH_AUTH);
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It is odd to be adding authentication parameters to a URL, but here the URL has multiple purposes–this is a URL to which information is going to be sent to, it also represents a logical end point. These three parameters (and other authentication parameters) get stripped from the HTTP URL before Camel makes the HTTP request. &lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:be2633b2f8769813832c8d38507c50a1:3&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:be2633b2f8769813832c8d38507c50a1:3&#34;&gt;3&lt;/a&gt;&lt;/sup&gt; This still will cause issues in odd cases where the HTTP A.P.I. you are integrating with expects these parameters to be sent.&lt;/p&gt;

&lt;h3 id=&#34;setting-authorization-headers:be2633b2f8769813832c8d38507c50a1&#34;&gt;Setting Authorization headers&lt;/h3&gt;

&lt;p&gt;Camel allows the addition of headers to messages that it processes and if the message ultimately gets routed to a Camel HTTP end point, these headers get converted to HTTP headers. This allows us to use authentication by setting the &lt;code&gt;Authorization&lt;/code&gt; header. This example demonstrates this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;    public void configure() throws Exception {
        from(&amp;quot;direct:start&amp;quot;)
                .marshal()
                .string(UTF_8)
                .split(body().tokenize())
                .streaming()
                .setHeader(CONTENT_TYPE, simple(APPLICATION_JSON))
                .setHeader(&amp;quot;Authorization&amp;quot;, simple(&amp;quot;Basic dGVzdDp0ZXN0&amp;quot;))
                .to(TARGET);
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;overriding-httpconfiguration:be2633b2f8769813832c8d38507c50a1&#34;&gt;Overriding HttpConfiguration&lt;/h3&gt;

&lt;p&gt;Camel provides a mechanism to override it‘s Context‘s configuration before the context gets created. In the following example, we get a reference to the &lt;code&gt;HttpComponent&lt;/code&gt; and set a new &lt;code&gt;HttpConfiguration&lt;/code&gt; with the right authentication. This allows us to separate the authentication configurations from the route definitions. However, if your Camel context is responsible for talking to different HTTP end points with different authentication mechanisms or parameters, this will not solve the issue.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;    @Bean
    CamelContextConfiguration contextConfiguration() {
        return camelContext -&amp;gt; {
            HttpComponent http = (HttpComponent) camelContext.getComponent(&amp;quot;http&amp;quot;);
            http.setHttpConfiguration(httpConfiguration());
        };
    }

    private HttpConfiguration httpConfiguration() {
        HttpConfiguration httpConfiguration = new HttpConfiguration();
        httpConfiguration.setAuthMethod(authScheme);
        httpConfiguration.setAuthUsername(authUsername);
        httpConfiguration.setAuthPassword(authPassword);
        return httpConfiguration;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In the end, the method you choose will depend on the unique constraints of the systems you are integrating with.&lt;/p&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:be2633b2f8769813832c8d38507c50a1:1&#34;&gt;&lt;a href=&#34;https://camel.apache.org/&#34;&gt;Apache Camel&lt;/a&gt; is a Java integration framework.
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:be2633b2f8769813832c8d38507c50a1:1&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:be2633b2f8769813832c8d38507c50a1:2&#34;&gt;Camel&amp;rsquo;s Domain Specific Language in Java allows integration routes to be defined as fluent specifications.
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:be2633b2f8769813832c8d38507c50a1:2&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:be2633b2f8769813832c8d38507c50a1:3&#34;&gt;Stripping of these parameters is done inside &lt;code&gt;org.apache.camel.component.http.HttpComponent&lt;/code&gt;‘s &lt;code&gt;createHttpClientConfigurer&lt;/code&gt; &lt;a href=&#34;https://github.com/apache/camel/blob/f7f0b18f6924fe0b01f32a25ed1e38e29b1bf8e5/components/camel-http/src/main/java/org/apache/camel/component/http/HttpComponent.java#L66&#34;&gt;method&lt;/a&gt;.
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:be2633b2f8769813832c8d38507c50a1:3&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Integration testing Spring command line applications</title>
      <link>http://sdqali.in/blog/2015/12/11/integration-testing-spring-command-line-applications/</link>
      <pubDate>Fri, 11 Dec 2015 15:57:30 -0500</pubDate>
      
      <guid>http://sdqali.in/blog/2015/12/11/integration-testing-spring-command-line-applications/</guid>
      <description>&lt;p&gt;In the &lt;a href=&#34;http://sdqali.in/blog/2015/12/10/integration-testing-challenges-for-non-web-spring-applications/&#34;&gt;last blog post&lt;/a&gt;, I wrote about the challenges of writing an integration test for a Spring command line application. One of the solutions for this issue discussed in the blog post was to use the &lt;code&gt;@IntegrationTest&lt;/code&gt; annotations to inject Java system properties and use that to run the application instead of the normal command line arguments. This blog post describes how to perform this.&lt;/p&gt;

&lt;p&gt;The first step is to rewrite our test to use the &lt;code&gt;@IntegrationTest&lt;/code&gt; annotations. This will result in a test that looks as follows:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@RunWith(SpringJUnit4ClassRunner.class)
@SpringApplicationConfiguration(classes = {Application.class})
@IntegrationTest(value = &amp;quot;input:expectedOutput&amp;quot;)
public class ApplicationIntegrationTest {
    @Autowired
    private Application application;

    @Rule
    public OutputCapture outputCapture = new OutputCapture();

    @Test
    public void shouldGenerateResultFiles() throws Exception {
        application.run();
        assertTrue(outputCapture.toString().contains(&amp;quot;expectedOutput&amp;quot;));
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;At this point, it is worth taking a look at what the &lt;code&gt;@IntegrationTest&lt;/code&gt; annotation causes Spring to do. This is a meta-annotation &lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:7dbd0b0b8fa67b28f9dffc46ddaee5e0:1&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:7dbd0b0b8fa67b28f9dffc46ddaee5e0:1&#34;&gt;1&lt;/a&gt;&lt;/sup&gt; that specifies a number of test listeners including &lt;code&gt;IntegrationTestPropertiesListener&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Documented
@Inherited
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.TYPE)
@TestExecutionListeners(listeners = { IntegrationTestPropertiesListener.class,
        DirtiesContextBeforeModesTestExecutionListener.class,
        DependencyInjectionTestExecutionListener.class,
        DirtiesContextTestExecutionListener.class,
        TransactionalTestExecutionListener.class, SqlScriptsTestExecutionListener.class })
public @interface IntegrationTest {
    String[] value() default {};
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;IntegrationTestPropertiesListener&lt;/code&gt; is an implementation of &lt;code&gt;TestExecutionListener&lt;/code&gt; which is a mechanism used by Spring to react to test execution events like &lt;code&gt;beforeTestClass&lt;/code&gt;, &lt;code&gt;prepareTestInstance&lt;/code&gt;, &lt;code&gt;beforeTestMethod&lt;/code&gt;, &lt;code&gt;beforeTestMethod&lt;/code&gt; and &lt;code&gt;afterTestClass&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;For the purposes of what we are trying to achieve, the listener we are really interested in is the &lt;code&gt;beforeTestClass&lt;/code&gt; of &lt;code&gt;IntegrationTestPropertiesListener&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;    @Override
    public void prepareTestInstance(TestContext testContext) throws Exception {
        Class&amp;lt;?&amp;gt; testClass = testContext.getTestClass();
        AnnotationAttributes annotationAttributes = AnnotatedElementUtils
                .getMergedAnnotationAttributes(testClass,
                        IntegrationTest.class.getName());
        if (annotationAttributes != null) {
            addPropertySourceProperties(testContext,
                    annotationAttributes.getStringArray(&amp;quot;value&amp;quot;));
        }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As we can see, the value of the &lt;code&gt;value&lt;/code&gt; element &lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:7dbd0b0b8fa67b28f9dffc46ddaee5e0:2&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:7dbd0b0b8fa67b28f9dffc46ddaee5e0:2&#34;&gt;2&lt;/a&gt;&lt;/sup&gt; of our &lt;code&gt;@IntegrationTest&lt;/code&gt; gets injected to the configuration of the test context.&lt;/p&gt;

&lt;p&gt;Now that we have understood and used the &lt;code&gt;@IntegrationTest&lt;/code&gt; annotation to push in configuration, it is time to make our application consume this configuration.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Configuration
@EnableAutoConfiguration
@ComponentScan
public class Application implements CommandLineRunner {
    @Autowired
    DataService dataService;

    @Value(&amp;quot;${input}&amp;quot;)
    String input;

    public static void main(String[] args) {
        SpringApplication.run(Application.class, args);
    }

    @Override
    public void run(String... args) {
        dataService.perform(input);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;An added benefit of this approach is that this forces us to use named parameter arguments when running the application as opposed to the position based command line arguments. This of course does not solve the problem of testing if you absolutely have to use position based arguments for your application. It would be nice Spring provided a mechanism to inject the command line arguments in a test before &lt;code&gt;SpringApplicationContextLoader&lt;/code&gt; &lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:7dbd0b0b8fa67b28f9dffc46ddaee5e0:3&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:7dbd0b0b8fa67b28f9dffc46ddaee5e0:3&#34;&gt;3&lt;/a&gt;&lt;/sup&gt; took over. But I suspect that this is not a common enough use case of Spring that users have asked the Spring team to implement it.&lt;/p&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:7dbd0b0b8fa67b28f9dffc46ddaee5e0:1&#34;&gt;Meta annotations are Spring annotations that can modify and act up on other annotations. For an example of customizing behavior using meta annotations, see &lt;a href=&#34;http://sdqali.in/blog/2015/12/06/implementing-custom-annotations-for-spring-mvc/&#34;&gt;this blog post&lt;/a&gt;.
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:7dbd0b0b8fa67b28f9dffc46ddaee5e0:1&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:7dbd0b0b8fa67b28f9dffc46ddaee5e0:2&#34;&gt;The tendency of programmers to name the default element of an annotation &lt;code&gt;value&lt;/code&gt; is one of my least favorite aspects of Java annotations. In most cases, there is another name that conveys the intent of the element better. I plan to write my thoughts about this in a blog post soon.
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:7dbd0b0b8fa67b28f9dffc46ddaee5e0:2&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:7dbd0b0b8fa67b28f9dffc46ddaee5e0:3&#34;&gt;See the previous blog post to see how &lt;code&gt;SpringApplicationContextLoader&lt;/code&gt; executes the application without arguments.
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:7dbd0b0b8fa67b28f9dffc46ddaee5e0:3&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Integration testing challenges for non-web Spring applications</title>
      <link>http://sdqali.in/blog/2015/12/10/integration-testing-challenges-for-non-web-spring-applications/</link>
      <pubDate>Thu, 10 Dec 2015 21:45:59 -0500</pubDate>
      
      <guid>http://sdqali.in/blog/2015/12/10/integration-testing-challenges-for-non-web-spring-applications/</guid>
      <description>&lt;p&gt;We are building a command line data loader application at work that uses Spring. One of the things that I took us more time that it should have to figure out was how to write an integration test that invokes the command line application with the right command line arguments. This blog post describes this scenario and a potential solution to this problem.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s consider a simple command line application implemented using Spring Boot&amp;rsquo;s &lt;code&gt;CommandLineRunner&lt;/code&gt;. The main application class is fairly simple.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;
@Configuration
@EnableAutoConfiguration
@ComponentScan
public class Application implements CommandLineRunner {
    @Autowired
    DataService dataService;

    public static void main(String[] args) {
        SpringApplication.run(Application.class, args);
    }

    @Override
    public void run(String... args) {
        dataService.perform(args[0]);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In addition to this, there is a configuration class &lt;code&gt;AppConfiguration&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Configuration
public class AppConfiguration {
    @Bean
    public DataService dataService() {
        return new DataService();
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;DataService&lt;/code&gt; simply prints the argument it receives.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class DataService {
    public void perform(String arg) {
        System.out.println(arg);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If we were to attempt writing an integration test for this application, it would look like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@RunWith(SpringJUnit4ClassRunner.class)
@SpringApplicationConfiguration(classes = {Application.class})
public class ApplicationIntegrationTest {
    @Autowired
    private Application application;


    @Rule
    public OutputCapture outputCapture = new OutputCapture();

    @Test
    public void shouldGenerateResultFiles() throws Exception {
        application.run(&amp;quot;sampleOutPut&amp;quot;);
        assertTrue(outputCapture.toString().contains(&amp;quot;sampleOutput&amp;quot;));
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That test is straightforward—it loads the Spring context with all the beans, runs the application with parameters and expects the parameter to be printed to the console.&lt;/p&gt;

&lt;p&gt;Except, it does not work. If we were to execute the above test, we will get the following error:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;...
Caused by: java.lang.ArrayIndexOutOfBoundsException: 0
at in.sdqali.springapps.Application.run(Application.java:24) ~[main/:na]
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;What happened? It looks like the &lt;code&gt;run&lt;/code&gt; method was called with out any arguments while the test configuration was loaded.&lt;/p&gt;

&lt;p&gt;Let‘s try and understand wh
y this happens. Remember how we annotated the test with &lt;code&gt;@SpringApplicationConfiguration&lt;/code&gt;? This annotation is a meta-annotation &lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:1944f35ca6adb86a80e399600f75145d:1&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:1944f35ca6adb86a80e399600f75145d:1&#34;&gt;1&lt;/a&gt;&lt;/sup&gt; specified as:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@ContextConfiguration(loader = SpringApplicationContextLoader.class)
@Documented
@Inherited
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.TYPE)
public @interface SpringApplicationConfiguration {
...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;ContextConfiguration&lt;/code&gt; is an annotation that allows tests to specify the information used to load and configure the application context. From the Java doc for this annotation:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; * {@code @ContextConfiguration} defines class-level metadata that is used to determine
 * how to load and configure an {@link org.springframework.context.ApplicationContext
 * ApplicationContext} for integration tests.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This brings us to &lt;code&gt;SpringApplicationContextLoader&lt;/code&gt;‘s &lt;code&gt;loadContext&lt;/code&gt; method and buried deep inside are these line:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;application.setInitializers(initializers);
ConfigurableApplicationContext applicationContext = application.run();
return applicationContext;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So, regardless of how many arguments our command line application was supposed to take, this loader always call the application without any arguments.&lt;/p&gt;

&lt;p&gt;There are two solutions I have been able to think of for this problem:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Override the&lt;code&gt;SpringApplicationContextLoader&lt;/code&gt; and pass the necessary arguments in &lt;code&gt;application.run()&lt;/code&gt;. This is definitely not an elegant or easy solution.&lt;/li&gt;
&lt;li&gt;Use an environment variable instead of the command line argument as the input to the service. This will allow us to inject this variable using the &lt;code&gt;@IntegrationTest&lt;/code&gt; annotation.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;My next blog post will discuss the second approach.&lt;/p&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:1944f35ca6adb86a80e399600f75145d:1&#34;&gt;Meta annotations. &lt;a href=&#34;http://docs.spring.io/spring/docs/current/spring-framework-reference/html/beans.html#beans-meta-annotations&#34;&gt;Spring documentation&lt;/a&gt;. To see how to use meta-annotations to write custom annoations, see &lt;a href=&#34;http://sdqali.in/blog/2015/12/06/implementing-custom-annotations-for-spring-mvc/&#34;&gt;this blog post&lt;/a&gt;.
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:1944f35ca6adb86a80e399600f75145d:1&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Implementing custom annotations for Spring MVC</title>
      <link>http://sdqali.in/blog/2015/12/06/implementing-custom-annotations-for-spring-mvc/</link>
      <pubDate>Sun, 06 Dec 2015 13:28:26 -0800</pubDate>
      
      <guid>http://sdqali.in/blog/2015/12/06/implementing-custom-annotations-for-spring-mvc/</guid>
      <description>&lt;p&gt;I often have to work with Spring MVC based code bases that have been living for a while. One of the common trait of these code bases I have observed is the repeated use of the same Spring annotations to achieve the same effect again and again. A really good example of this is annotating a controller method with a combination of &lt;code&gt;@RequestMapping&lt;/code&gt; and &lt;code&gt;@ResponseStatus&lt;/code&gt; to set the expected request and response &lt;code&gt;Content-Type&lt;/code&gt;, the request Method, response status etc. This blog post describes how to compose Spring annotations that produce the same effect as multiple Spring annotations acting together.&lt;/p&gt;

&lt;p&gt;Among the new things introduced in Spring 4 was the idea of meta-annotations. &lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:b72714563591dcee83238042a831f26c:1&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:b72714563591dcee83238042a831f26c:1&#34;&gt;1&lt;/a&gt;&lt;/sup&gt; Meta annotations are annotations that can act up on other annotations by modifying and overriding attributes of the target annotations.&lt;/p&gt;

&lt;p&gt;This allows us to build composed annotations &lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:b72714563591dcee83238042a831f26c:2&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:b72714563591dcee83238042a831f26c:2&#34;&gt;2&lt;/a&gt;&lt;/sup&gt; that combine the behavior of multiple annotations. The &lt;code&gt;@AliasFor&lt;/code&gt; annotation allows us to override attribute names, thereby adding great flexibility while composing.&lt;/p&gt;

&lt;p&gt;This is a common pattern in code bases that use Spring MVC.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;    @RequestMapping(path = &amp;quot;/register&amp;quot;,
            method = RequestMethod.POST,
            consumes = MediaType.APPLICATION_JSON_VALUE,
            produces = MediaType.APPLICATION_JSON_VALUE
    )
    @ResponseStatus(HttpStatus.CREATED)
    public Map register(@RequestBody @Valid EmailRequest emailRequest) {
        return registrationService.register(emailRequest);
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The two annotations as applied on this method represent the fact that this is an end point that a client can &lt;code&gt;POST&lt;/code&gt; JSON to and produces JSON and a &lt;code&gt;201 Created&lt;/code&gt; HTTP status when it succeeds. If we had 20 end points that did the similar operations, it would be really useful to have a &lt;code&gt;@PostJson&lt;/code&gt; annotation that did the same thing.&lt;/p&gt;

&lt;p&gt;The following is one way of writing such an annotation.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Target(METHOD)
@Retention(RUNTIME)
@Documented
@RequestMapping(method = RequestMethod.POST,
        consumes = MediaType.APPLICATION_JSON_VALUE,
        produces = MediaType.APPLICATION_JSON_VALUE
)
@ResponseStatus(HttpStatus.CREATED)
public @interface PostJson {
    @AliasFor(annotation = RequestMapping.class, attribute = &amp;quot;path&amp;quot;)
    String[] path() default {};
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This annotation takes a single parameter &lt;code&gt;path&lt;/code&gt; that represents that URL path to which it will respond to. This can now be applied on the register end point.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;    @PostJson(path = &amp;quot;/register&amp;quot;)
    public Map register(@RequestBody @Valid EmailRequest emailRequest) {
        return registrationService.register(emailRequest);
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If we wanted to allow the consumers of &lt;code&gt;@PostJson&lt;/code&gt; to override other parameters of &lt;code&gt;@RequestMapping&lt;/code&gt; or &lt;code&gt;@ResponseStatus&lt;/code&gt;, it can be achieved by adding more aliases. For example, the following will allow users to specify a reason phrase.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;    @AliasFor(annotation = ResponseStatus.class, attribute = &amp;quot;reason&amp;quot;)
    String[] reason() default {};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This pattern can easily be extended to introduce annotations like &lt;code&gt;@GetJson&lt;/code&gt;, &lt;code&gt;@PutJson&lt;/code&gt;, &lt;code&gt;@PostXml&lt;/code&gt; and so on and so forth.&lt;/p&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:b72714563591dcee83238042a831f26c:1&#34;&gt;Meta annotations. &lt;a href=&#34;http://docs.spring.io/spring/docs/current/spring-framework-reference/html/beans.html#beans-meta-annotations&#34;&gt;Spring documentation&lt;/a&gt;.
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:b72714563591dcee83238042a831f26c:1&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:b72714563591dcee83238042a831f26c:2&#34;&gt;Composed annotations. &lt;a href=&#34;https://github.com/spring-projects/spring-framework/wiki/Spring-Annotation-Programming-Model#composed-annotations&#34;&gt;Spring documentation&lt;/a&gt;.
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:b72714563591dcee83238042a831f26c:2&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Validating RequestParams and PathVariables in Spring MVC</title>
      <link>http://sdqali.in/blog/2015/12/04/validating-requestparams-and-pathvariables-in-spring-mvc/</link>
      <pubDate>Fri, 04 Dec 2015 22:50:24 -0800</pubDate>
      
      <guid>http://sdqali.in/blog/2015/12/04/validating-requestparams-and-pathvariables-in-spring-mvc/</guid>
      <description>&lt;p&gt;Spring MVC provides a convenient way to validate inputs to API end points through the use of &lt;code&gt;JSR-303&lt;/code&gt; annotations. While this mechanism works great for end points that consume a &lt;code&gt;RequestBody&lt;/code&gt; (as is the case with most &lt;code&gt;POST&lt;/code&gt; and &lt;code&gt;PUT&lt;/code&gt; requests), it is not easy to achieve the same effect for end points that consume primitives in the form of path variables or request parameters (as is the case with most &lt;code&gt;GET&lt;/code&gt; requests).&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s take a look at how to validate RequestBody inputs using JSR-303.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;    @RequestMapping(method = RequestMethod.POST,
            consumes = MediaType.APPLICATION_JSON_VALUE,
            produces = MediaType.APPLICATION_JSON_VALUE
    )
    @ResponseStatus(HttpStatus.OK)
    public Map register(@RequestBody @Valid EmailRequest emailRequest) {
        return registrationService.register(emailRequest);
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The value object &lt;code&gt;EmailRequest&lt;/code&gt; is annotated with the appropriate constraint annotations.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class EmailRequest {
    @Email
    public String email;

    private EmailRequest() {
    }

    public String getEmail() {
        return email;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If we were to attempt a similar approach for a &lt;code&gt;GET&lt;/code&gt; end point that accepts a &lt;code&gt;RequestParam&lt;/code&gt;, the validation would simply not happen.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;    @RequestMapping(method = RequestMethod.GET,
            consumes = MediaType.APPLICATION_JSON_VALUE,
            produces = MediaType.APPLICATION_JSON_VALUE
    )
    @ResponseStatus(HttpStatus.OK)
    public Map search(@Email
                   @Valid
                   @RequestParam(&amp;quot;email&amp;quot;)
                   String email) {
        return emailMessage(email);
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is where Spring&amp;rsquo;s &lt;code&gt;@Validated&lt;/code&gt; annotation is useful. With &lt;code&gt;@Validated&lt;/code&gt;, we can validate request parameters and path variables.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@RestController
@Validated
public class RegistrationController {
    @RequestMapping(method = RequestMethod.GET,
            consumes = MediaType.APPLICATION_JSON_VALUE,
            produces = MediaType.APPLICATION_JSON_VALUE
    )
    @ResponseStatus(HttpStatus.OK)
    public Map search(@Email
                   @RequestParam(&amp;quot;email&amp;quot;)
                   String email) {
        return emailMessage(email);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;An important thing to note here is that using &lt;code&gt;@Valid&lt;/code&gt; annotation results in &lt;code&gt;MethodArgumentNotValidException&lt;/code&gt; being thrown when validation fails, but &lt;code&gt;@Validated&lt;/code&gt; results in &lt;code&gt;ConstraintViolationException&lt;/code&gt; being thrown. Since these exceptions have different ways of abstracting the error messages associated with validation, it is important to have different error handlers for both of these. An example pattern using &lt;code&gt;ExceptionHandler&lt;/code&gt; will be as follows:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@ControllerAdvice
@Component
public class GlobalExceptionHandler {
    @ExceptionHandler
    @ResponseBody
    @ResponseStatus(HttpStatus.BAD_REQUEST)
    public Map handle(MethodArgumentNotValidException exception) {
        return error(exception.getBindingResult().getFieldErrors()
                .stream()
                .map(FieldError::getDefaultMessage)
                .collect(Collectors.toList()));
    }


    @ExceptionHandler
    @ResponseBody
    @ResponseStatus(HttpStatus.BAD_REQUEST)
    public Map handle(ConstraintViolationException exception) {
        return error(exception.getConstraintViolations()
                .stream()
                .map(ConstraintViolation::getMessage)
                .collect(Collectors.toList()));
    }

    private Map error(Object message) {
        return Collections.singletonMap(&amp;quot;error&amp;quot;, message);
    }
}

&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Testing async responses using MockMvc</title>
      <link>http://sdqali.in/blog/2015/11/24/testing-async-responses-using-mockmvc/</link>
      <pubDate>Tue, 24 Nov 2015 05:45:06 -0500</pubDate>
      
      <guid>http://sdqali.in/blog/2015/11/24/testing-async-responses-using-mockmvc/</guid>
      <description>&lt;p&gt;There are times when a Spring MVC end point performs asynchronous operations. Testing these end points using MockMvc can be tricky because of the asynchronous nature in which the result of the operation is eventually returned. This blog post describes how to write tests in such scenarios.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s take a look at the following example. In this example, we have a simple end point that responds with a JSON object when invoked.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@RestController
@RequestMapping(&amp;quot;/test&amp;quot;)
class ExampleController {
    @RequestMapping(value = &amp;quot;/hello&amp;quot;,
            method = GET,
            consumes = APPLICATION_JSON_VALUE,
            produces = APPLICATION_JSON_VALUE)
    @ResponseStatus(OK)
    public Map&amp;lt;String, Object&amp;gt; hello(){
        return helloMessage();
    }

    private Map&amp;lt;String, Object&amp;gt; helloMessage() {
        return Collections.singletonMap(&amp;quot;message&amp;quot;, &amp;quot;hello&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Writing a MockMvc test for this controller is fairly simple. The following test invokes the end point and asserts that the end point returns:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;The right HTTP response code &lt;code&gt;200&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;The right Content-Type &lt;code&gt;application/json&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;The right JSON message&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@RunWith(MockitoJUnitRunner.class)
public class ExampleControllerTest {

    public static final String CONTENT_TYPE = &amp;quot;Content-Type&amp;quot;;
    private ExampleController controller;
    private MockMvc mockMvc;

    @Before
    public void setUp() {
        controller = new ExampleController();
        mockMvc = MockMvcBuilders
                .standaloneSetup(controller)
                .build();
    }

    @Test
    public void shouldHaveAMessageInResponse() throws Exception {
        mockMvc
                .perform(get(&amp;quot;/test/hello&amp;quot;)
                        .contentType(APPLICATION_JSON))
                .andDo(print())
                .andExpect(status().isOk())
                .andExpect(header().string(CONTENT_TYPE, APPLICATION_JSON_VALUE))
                .andExpect(jsonPath(&amp;quot;message&amp;quot;).value(&amp;quot;hello&amp;quot;));
    }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now, lets try and write a similar test for an end point uses &lt;code&gt;DeferredResult&lt;/code&gt; to do asynchronous request processing. The end point in this example just wraps the JSON structure in &lt;code&gt;DeferredResult&lt;/code&gt; and returns, whereas there will be a long running asynchronous process in a more useful case. But the idea remains the same.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;    @RequestMapping(value = &amp;quot;/deferred&amp;quot;,
            method = GET,
            consumes = APPLICATION_JSON_VALUE,
            produces = APPLICATION_JSON_VALUE
    )
    @ResponseStatus(OK)
    public DeferredResult&amp;lt;Map&amp;gt; deferred() {
        DeferredResult&amp;lt;Map&amp;gt; deferredResult = new DeferredResult&amp;lt;&amp;gt;();
        deferredResult.setResult(helloMessage());
        return deferredResult;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If our test for this end point were to use the same mechanism as the previous test, we will start observing an interesting error.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;    @Test
    public void shouldHaveAMessageInDeferredResponse() throws Exception {
        mockMvc
                .perform(get(&amp;quot;/test/deferred&amp;quot;)
                        .contentType(APPLICATION_JSON))
                .andExpect(status().isOk())
                .andExpect(header().string(CONTENT_TYPE, APPLICATION_JSON_VALUE))
                .andExpect(jsonPath(&amp;quot;message&amp;quot;).value(&amp;quot;hello&amp;quot;));
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;Response header Content-Type expected:&amp;lt;application/json&amp;gt; but was:&amp;lt;null&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This happened because MockMvc did not wait for the asynchronous process to finish. The solution to this involves using MockMvc&amp;rsquo;s &lt;code&gt;asyncDispatch&lt;/code&gt;. AsyncDispatch creates a new request that continues from the result of a previous MockMvc request that started the asynchronous process.
The test re-written using &lt;code&gt;asyncDispatch&lt;/code&gt; would be as follows:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;    @Test
    public void shouldHaveAMessageInDeferredResponseWithAsyncDispatch() throws Exception {
        MvcResult result = mockMvc
                .perform(get(&amp;quot;/test/deferred&amp;quot;)
                        .contentType(APPLICATION_JSON))
                .andReturn();

        mockMvc
                .perform(asyncDispatch(result))
                .andExpect(status().isOk())
                .andExpect(header().string(CONTENT_TYPE, APPLICATION_JSON_VALUE))
                .andExpect(jsonPath(&amp;quot;message&amp;quot;).value(&amp;quot;hello&amp;quot;));
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The same approach can be employed to test when controllers use Java 8&amp;rsquo;s &lt;code&gt;CompletableFuture&lt;/code&gt;.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Running multiple applications in the same Tomcat installation</title>
      <link>http://sdqali.in/blog/2015/06/09/running-multiple-applications-in-the-same-tomcat-installation/</link>
      <pubDate>Tue, 09 Jun 2015 01:11:05 -0400</pubDate>
      
      <guid>http://sdqali.in/blog/2015/06/09/running-multiple-applications-in-the-same-tomcat-installation/</guid>
      <description>

&lt;p&gt;This blog post describes how to set up Tomcat to run multiple applications running as separate JVM processes, using the same Tomcat installation. This method utilizes the &lt;code&gt;CATALINA_HOME&lt;/code&gt; and &lt;code&gt;CATALINA_BASE&lt;/code&gt; environment variables used by Tomcat. I have verified this method against Tomcat versions &lt;code&gt;8.0.x&lt;/code&gt;; other versions should work the same way.&lt;/p&gt;

&lt;h2 id=&#34;a-typical-tomcat-installation:a2ed05b8bb95da785f1e814e64b0e342&#34;&gt;A typical Tomcat installation&lt;/h2&gt;

&lt;p&gt;If we explode the Tomcat 8.0.23 &lt;a href=&#34;http://mirrors.sonic.net/apache/tomcat/tomcat-8/v8.0.23/bin/apache-tomcat-8.0.23.tar.gz&#34;&gt;tarball&lt;/a&gt;, we get the following directory structure:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ tar apache-tomcat-8.0.23.tar.gz

$ ls apache-tomcat-8.0.23/
LICENSE		RELEASE-NOTES	bin		lib		temp		work
NOTICE		RUNNING.txt	conf		logs		webapps
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This distribution, by default runs applications in a single JVM. How does it do this?&lt;/p&gt;

&lt;p&gt;Tomcat control scripts - &lt;code&gt;startup.sh&lt;/code&gt;, &lt;code&gt;shutdown.sh&lt;/code&gt;, &lt;code&gt;catalina.sh&lt;/code&gt; uses the environment variables &lt;code&gt;CATALINA_HOME&lt;/code&gt; and &lt;code&gt;CATALINA_BASE&lt;/code&gt; to locate binaries and configuration files.&lt;/p&gt;

&lt;p&gt;From the documentaion inside &lt;code&gt;catalina.sh&lt;/code&gt; under &lt;code&gt;apache-tomcat-8.0.23/bin/&lt;/code&gt; we can see that:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#   CATALINA_HOME   May point at your Catalina &amp;quot;build&amp;quot; directory.
#
#   CATALINA_BASE   (Optional) Base directory for resolving dynamic portions
#                   of a Catalina installation.  If not present, resolves to
#                   the same directory that CATALINA_HOME points to.

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This allows us to separate the &lt;code&gt;CATALINA_HOME&lt;/code&gt; and &lt;code&gt;CATALINA_BASE&lt;/code&gt; directories. The Tomcat binaries and scripts need to be inside &lt;code&gt;CATALINA_HOME&lt;/code&gt; and our first application can deploy itself to &lt;code&gt;CATALINA_BASE&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&#34;separating-catalina-home-and-catalina-base:a2ed05b8bb95da785f1e814e64b0e342&#34;&gt;Separating CATALINA_HOME and CATALINA_BASE&lt;/h2&gt;

&lt;p&gt;The &lt;code&gt;app1&lt;/code&gt; directory will have the following directories:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ ls -a app1/
.	..	bin	conf	logs	temp	webapps	work
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;bin&lt;/code&gt; directory will have the &lt;code&gt;setenv.sh&lt;/code&gt; script used to set additional environment variables for the application.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;tomcat&lt;/code&gt; directory will have the following directories:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;
$ ls tomcat/
LICENSE		NOTICE		RELEASE-NOTES	RUNNING.txt	bin		lib
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;bin&lt;/code&gt; directory will have the Tomcat management scripts like &lt;code&gt;startup.sh&lt;/code&gt;, &lt;code&gt;shutdown.sh&lt;/code&gt;, &lt;code&gt;catalina.sh&lt;/code&gt; etc.&lt;/p&gt;

&lt;p&gt;Now we can start &lt;code&gt;app1&lt;/code&gt; by pointing &lt;code&gt;CATALINA_BASE&lt;/code&gt; to &lt;code&gt;app1&lt;/code&gt; and &lt;code&gt;CATALINA_HOME&lt;/code&gt; to &lt;code&gt;tomcat&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;
$ export CATALINA_HOME=/Users/sdqali/src/sandbox/tomcat

$ export CATALINA_BASE=/Users/sdqali/src/sandbox/app1

$ $CATALINA_HOME/bin/startup.sh

$ $CATALINA_HOME/bin/startup.sh
Using CATALINA_BASE:   /Users/sdqali/src/sandbox/app1
Using CATALINA_HOME:   /Users/sdqali/src/sandbox/tomcat
Using CATALINA_TMPDIR: /Users/sdqali/src/sandbox/app1/temp
Using JRE_HOME:        /Library/Java/JavaVirtualMachines/jdk1.8.0_45.jdk/Contents/Home
Using CLASSPATH:       /Users/sdqali/src/sandbox/tomcat/bin/bootstrap.jar:/Users/sdqali/src/sandbox/tomcat/bin/tomcat-juli.jar
Tomcat started.

$ curl -s -D - -o /dev/null http://127.0.0.1:8080
HTTP/1.1 200 OK
Server: Apache-Coyote/1.1
Content-Type: text/html;charset=UTF-8
Transfer-Encoding: chunked
Date: Tue, 09 Jun 2015 07:37:43 GMT
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let&amp;rsquo;s try and deploy a second application &lt;code&gt;app2&lt;/code&gt; running on port &lt;code&gt;9090&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;
$ export CATALINA_HOME=/Users/sdqali/src/sandbox/tomcat

$ export CATALINA_BASE=/Users/sdqali/src/sandbox/app2

$ $CATALINA_HOME/bin/startup.sh
Using CATALINA_BASE:   /Users/sdqali/src/sandbox/app2
Using CATALINA_HOME:   /Users/sdqali/src/sandbox/tomcat
Using CATALINA_TMPDIR: /Users/sdqali/src/sandbox/app2/temp
Using JRE_HOME:        /Library/Java/JavaVirtualMachines/jdk1.8.0_45.jdk/Contents/Home
Using CLASSPATH:       /Users/sdqali/src/sandbox/tomcat/bin/bootstrap.jar:/Users/sdqali/src/sandbox/tomcat/bin/tomcat-juli.jar
Tomcat started.

$ curl -s -D - -o /dev/null http://127.0.0.1:9090
HTTP/1.1 200 OK
Server: Apache-Coyote/1.1
Content-Type: text/html;charset=UTF-8
Transfer-Encoding: chunked
Date: Tue, 09 Jun 2015 07:41:02 GMT
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;tying-it-all-together:a2ed05b8bb95da785f1e814e64b0e342&#34;&gt;Tying it all together&lt;/h2&gt;

&lt;p&gt;At this point, it is useful to create management scripts that abstract away the environment variables and allows for starting up and shutting down applications individually. The &lt;code&gt;start.sh&lt;/code&gt; script will be as follows.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#!/usr/bin/env sh

# start.sh
# Script to start a Tomcat application

show_usage() {
    echo &amp;quot;Usage: ./start.sh &amp;lt;app-name&amp;gt;&amp;quot;;
    exit 1;
}

declare app_name=$1;
[[ -z $app_name ]] &amp;amp;&amp;amp; show_usage;


declare INSTALL_BASE=/Users/sdqali/src/sandbox

export CATALINA_HOME=$INSTALL_BASE/tomcat
export CATALINA_BASE=$INSTALL_BASE/$app_name

$CATALINA_HOME/bin/startup.sh
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Similarly, the &lt;code&gt;stop.sh&lt;/code&gt; script will be:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#!/usr/bin/env sh

# stop.sh
# Script to stop a Tomcat application

show_usage() {
    echo &amp;quot;Usage: ./stop.sh &amp;lt;app-name&amp;gt;&amp;quot;;
    exit 1;
}

declare app_name=$1;
[[ -z $app_name ]] &amp;amp;&amp;amp; show_usage;


declare INSTALL_BASE=/Users/sdqali/src/sandbox

export CATALINA_HOME=$INSTALL_BASE/tomcat
export CATALINA_BASE=$INSTALL_BASE/$app_name

$CATALINA_HOME/bin/shutdown.sh
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can manage individual applications using these scripts:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ ./management/start.sh app2
Using CATALINA_BASE:   /Users/sdqali/src/sandbox/app2
Using CATALINA_HOME:   /Users/sdqali/src/sandbox/tomcat
Using CATALINA_TMPDIR: /Users/sdqali/src/sandbox/app2/temp
Using JRE_HOME:        /Library/Java/JavaVirtualMachines/jdk1.8.0_45.jdk/Contents/Home
Using CLASSPATH:       /Users/sdqali/src/sandbox/tomcat/bin/bootstrap.jar:/Users/sdqali/src/sandbox/tomcat/bin/tomcat-juli.jar
Tomcat started.

$ nc -z  127.0.0.1 9090
Connection to 127.0.0.1 port 9090 [tcp/websm] succeeded!

$ curl -s -D - -o /dev/null http://127.0.0.1:9090
HTTP/1.1 200 OK
Server: Apache-Coyote/1.1
Content-Type: text/html;charset=UTF-8
Transfer-Encoding: chunked
Date: Tue, 09 Jun 2015 08:16:05 GMT


$ ./management/stop.sh app2
Using CATALINA_BASE:   /Users/sdqali/src/sandbox/app2
Using CATALINA_HOME:   /Users/sdqali/src/sandbox/tomcat
Using CATALINA_TMPDIR: /Users/sdqali/src/sandbox/app2/temp
Using JRE_HOME:        /Library/Java/JavaVirtualMachines/jdk1.8.0_45.jdk/Contents/Home
Using CLASSPATH:       /Users/sdqali/src/sandbox/tomcat/bin/bootstrap.jar:/Users/sdqali/src/sandbox/tomcat/bin/tomcat-juli.jar

$ nc -z  127.0.0.1 9090

$ curl -v http://127.0.0.1:9090
* Rebuilt URL to: http://127.0.0.1:9090/
* Hostname was NOT found in DNS cache
*   Trying 127.0.0.1...
* connect to 127.0.0.1 port 9090 failed: Connection refused
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
  </channel>
</rss>