<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en-us">
<head>
  <link href="http://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">

  
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  <title> Testing async responses using MockMvc &middot; Sadique Ali </title>

  
  <link rel="stylesheet" href="http://sdqali.in/css/poole.css">
  <link rel="stylesheet" href="http://sdqali.in/css/syntax.css">
  <link rel="stylesheet" href="http://sdqali.in/css/hyde.css">
  <link rel="stylesheet" href="http://sdqali.in/css/default.min.css">
  <link rel="stylesheet" href="http://sdqali.in/css/custom.css">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=PT+Sans:400,400italic,700|Abril+Fatface">

  
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/apple-touch-icon-144-precomposed.png">
  <link rel="shortcut icon" href="/favicon.ico">

  
  <link href="" rel="alternate" type="application/rss+xml" title="Sadique Ali" />

  <script type="text/javascript" src="http://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.0.0/highlight.min.js"></script>
  <script type="text/javascript">
    hljs.initHighlightingOnLoad();
  </script>
</head>


<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:site" content="@sdqali">
<meta name="twitter:creator" content="@sdqali">
<meta name="twitter:title" content="Testing async responses using MockMvc">
<meta name="twitter:description" content="There are times when a Spring MVC end point performs asynchronous operations. Testing these end points using MockMvc can be tricky because of the asynchronous nature in which the result of the operation is eventually returned. This blog post describes how to write tests in such scenarios.
">
<meta name="twitter:image" content="http://sdqali.in/images/spring-by-pivotal.png">

<body class="theme-base-0b">

<div class="sidebar">
  <div class="container sidebar-sticky">
    <div class="sidebar-about">
      <h1>
	<a href="/">Sadique Ali</a>
      </h1>
      <p class="lead">
       A blog about the Code I write and the Technologies I use. And other things that interest me. 
      </p>
    </div>

    <ul class="sidebar-nav">
      <li><a href="/">Home</a> </li>
      <li><a href="/blog/">Blog</a> </li>
      <li><a href="/about">About</a> </li>
      <li><a href="https://github.com/sdqali">GitHub</a> </li>
      <li><a href="https://twitter.com/sdqali">Twitter</a> </li>
      <li><a href="https://www.linkedin.com/in/sdqali">LinkedIn</a> </li>
      
    </ul>

    <p>&copy; 2015. All rights reserved. </p>
  </div>
</div>


    <div class="content container">
<div class="post">
  <h1>Testing async responses using MockMvc</h1>
  <span class="post-date">Tue, Nov 24, 2015</span>
      <p>There are times when a Spring MVC end point performs asynchronous operations. Testing these end points using MockMvc can be tricky because of the asynchronous nature in which the result of the operation is eventually returned. This blog post describes how to write tests in such scenarios.</p>

<p>Let&rsquo;s take a look at the following example. In this example, we have a simple end point that responds with a JSON object when invoked.</p>

<pre><code class="language-java">@RestController
@RequestMapping(&quot;/test&quot;)
class ExampleController {
    @RequestMapping(value = &quot;/hello&quot;,
            method = GET,
            consumes = APPLICATION_JSON_VALUE,
            produces = APPLICATION_JSON_VALUE)
    @ResponseStatus(OK)
    public Map&lt;String, Object&gt; hello(){
        return helloMessage();
    }

    private Map&lt;String, Object&gt; helloMessage() {
        return Collections.singletonMap(&quot;message&quot;, &quot;hello&quot;);
    }
}
</code></pre>

<p>Writing a MockMvc test for this controller is fairly simple. The following test invokes the end point and asserts that the end point returns:</p>

<ul>
<li>The right HTTP response code <code>200</code></li>
<li>The right Content-Type <code>application/json</code></li>
<li>The right JSON message</li>
</ul>

<pre><code class="language-java">@RunWith(MockitoJUnitRunner.class)
public class ExampleControllerTest {

    public static final String CONTENT_TYPE = &quot;Content-Type&quot;;
    private ExampleController controller;
    private MockMvc mockMvc;

    @Before
    public void setUp() {
        controller = new ExampleController();
        mockMvc = MockMvcBuilders
                .standaloneSetup(controller)
                .build();
    }

    @Test
    public void shouldHaveAMessageInResponse() throws Exception {
        mockMvc
                .perform(get(&quot;/test/hello&quot;)
                        .contentType(APPLICATION_JSON))
                .andDo(print())
                .andExpect(status().isOk())
                .andExpect(header().string(CONTENT_TYPE, APPLICATION_JSON_VALUE))
                .andExpect(jsonPath(&quot;message&quot;).value(&quot;hello&quot;));
    }
}

</code></pre>

<p>Now, lets try and write a similar test for an end point uses <code>DeferredResult</code> to do asynchronous request processing. The end point in this example just wraps the JSON structure in <code>DeferredResult</code> and returns, whereas there will be a long running asynchronous process in a more useful case. But the idea remains the same.</p>

<pre><code class="language-java">    @RequestMapping(value = &quot;/deferred&quot;,
            method = GET,
            consumes = APPLICATION_JSON_VALUE,
            produces = APPLICATION_JSON_VALUE
    )
    @ResponseStatus(OK)
    public DeferredResult&lt;Map&gt; deferred() {
        DeferredResult&lt;Map&gt; deferredResult = new DeferredResult&lt;&gt;();
        deferredResult.setResult(helloMessage());
        return deferredResult;
    }
</code></pre>

<p>If our test for this end point were to use the same mechanism as the previous test, we will start observing an interesting error.</p>

<pre><code class="language-java">    @Test
    public void shouldHaveAMessageInDeferredResponse() throws Exception {
        mockMvc
                .perform(get(&quot;/test/deferred&quot;)
                        .contentType(APPLICATION_JSON))
                .andExpect(status().isOk())
                .andExpect(header().string(CONTENT_TYPE, APPLICATION_JSON_VALUE))
                .andExpect(jsonPath(&quot;message&quot;).value(&quot;hello&quot;));
    }
</code></pre>

<pre><code class="language-bash">Response header Content-Type expected:&lt;application/json&gt; but was:&lt;null&gt;
</code></pre>

<p>This happened because MockMvc did not wait for the asynchronous process to finish. The solution to this involves using MockMvc&rsquo;s <code>asyncDispatch</code>. AsyncDispatch creates a new request that continues from the result of a previous MockMvc request that started the asynchronous process.
The test re-written using <code>asyncDispatch</code> would be as follows:</p>

<pre><code class="language-java">    @Test
    public void shouldHaveAMessageInDeferredResponseWithAsyncDispatch() throws Exception {
        MvcResult result = mockMvc
                .perform(get(&quot;/test/deferred&quot;)
                        .contentType(APPLICATION_JSON))
                .andReturn();

        mockMvc
                .perform(asyncDispatch(result))
                .andExpect(status().isOk())
                .andExpect(header().string(CONTENT_TYPE, APPLICATION_JSON_VALUE))
                .andExpect(jsonPath(&quot;message&quot;).value(&quot;hello&quot;));
    }
</code></pre>

<p>The same approach can be employed to test when controllers use Java 8&rsquo;s <code>CompletableFuture</code>.</p>

</div>
</div>

  </body>
</html>
