<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en-us" prefix="og: http://ogp.me/ns#">
  <head>
    <link href="http://gmpg.org/xfn/11" rel="profile">
    <meta http-equiv="content-type" content="text/html; charset=utf-8">

    
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

    <title> On REST, Content-Type, Google Chrome and Caching &middot; Sadique Ali </title>

    
    <link rel="stylesheet" href="http://sdqali.in/css/poole.css">
    <link rel="stylesheet" href="http://sdqali.in/css/syntax.css">
    <link rel="stylesheet" href="http://sdqali.in/css/hyde.css">
    <link rel="stylesheet" href="http://sdqali.in/css/default.min.css">
    <link rel="stylesheet" href="http://sdqali.in/css/custom.css">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=PT+Sans:400,400italic,700|Abril+Fatface">

    
    <link rel="apple-touch-icon" sizes="57x57" href="/apple-touch-icon-57x57.png">
    <link rel="apple-touch-icon" sizes="60x60" href="/apple-touch-icon-60x60.png">
    <link rel="apple-touch-icon" sizes="72x72" href="/apple-touch-icon-72x72.png">
    <link rel="apple-touch-icon" sizes="76x76" href="/apple-touch-icon-76x76.png">
    <link rel="apple-touch-icon" sizes="114x114" href="/apple-touch-icon-114x114.png">
    <link rel="apple-touch-icon" sizes="120x120" href="/apple-touch-icon-120x120.png">
    <link rel="apple-touch-icon" sizes="144x144" href="/apple-touch-icon-144x144.png">
    <link rel="apple-touch-icon" sizes="152x152" href="/apple-touch-icon-152x152.png">
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon-180x180.png">
    <link rel="icon" type="image/png" href="/favicon-32x32.png" sizes="32x32">
    <link rel="icon" type="image/png" href="/android-chrome-192x192.png" sizes="192x192">
    <link rel="icon" type="image/png" href="/favicon-96x96.png" sizes="96x96">
    <link rel="icon" type="image/png" href="/favicon-16x16.png" sizes="16x16">
    <link rel="manifest" href="/manifest.json">
    <link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">
    <meta name="msapplication-TileColor" content="#da532c">
    <meta name="msapplication-TileImage" content="/mstile-144x144.png">
    <meta name="theme-color" content="#ffffff">

    <script src="https://d26b395fwzu5fz.cloudfront.net/3.3.0/keen.min.js" type="text/javascript"></script>
    <script src="http://sdqali.in/js/parseuri.js" type="text/javascript"></script>
    <script src="http://sdqali.in/js/ua-parser.min.js" type="text/javascript"></script>
    <script src="http://sdqali.in/js/Math.uuid.js" type="text/javascript"></script>

    
    <link href="" rel="alternate" type="application/rss+xml" title="Sadique Ali" />

    <script type="text/javascript" src="http://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.0.0/highlight.min.js"></script>
    <script type="text/javascript">
      hljs.initHighlightingOnLoad();
    </script>

    <script type="text/javascript">
  var client = new Keen({
    projectId: "566f9f7a96773d75e098bb34", 
    writeKey: "5d41bf4e9b86ee088f2ae748d782f6e40501d9f1807e04cd3c2bea52c276f14416f585877c39785704bdd5407aae393cc8ad601646d2112f8293a0269145baebec15f48e073186173b9e6c82cd3767456296c77a46d23b827c82492116d919e8401dfa84c56f13adac91963575522314",   
    readKey: "57d95890c1893e97bb47ff02d5082242490a5f0585777e5f157ff3c5f01aca1c1e5bdaab91d874668b7154981d14dd5d73e3a54ef3360e93f29ea1b50b36b339e0e0fe063347fa6ce9bf9f1536752fa81bf2e12079a21e2e57312a55260403f09915e11455cb98e69a2dc9094c14184a"      
  });

var uri = parseUri(window.location.href);
var referrer = parseUri(document.referrer);
var uaParser = new UAParser();
client.addEvent("pagehit", {
  "url" : {
    "source" : uri.source,
    "protocol" : uri.protocol,
    "domain" : uri.host,
    "port" : uri.port,
    "path" : uri.path,
    "anchor" : uri.anchor
  },
  "user_agent" : {
    "browser" : uaParser.getBrowser(),
    "engine" : uaParser.getEngine(),
    "os" : uaParser.getOS()
  },
  referrer: {
    "source" : referrer.source,
    "protocol" : referrer.protocol,
    "domain" : referrer.host,
    "port" : referrer.port,
    "path" : referrer.path,
    "anchor" : referrer.anchor
  },
  "session_id" : Math.uuid(),
  "permanent_tracker" : Math.uuid()
});
</script>

  </head>


<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:site" content="@sdqali">
<meta name="twitter:creator" content="@sdqali">
<meta name="twitter:title" content="On REST, Content-Type, Google Chrome and Caching">
<meta name="twitter:description" content="Representational State Transfer (REST) is a style of software
architecture for distributed systems that has replaced technologies like
SOAP as the predominant Web service
design model. Originally proposed by Roy Fielding in his Doctorate
dissertation,
REST puts a lot of emphasis on resources, their representations and states. Basically a URL indicates a
single resource; the HTTP method (GET, POST, PUT, DELETE) indicates what
action should be performed on that resource; and the ACCEPT header indicates the format that the resource should be presented in.

Chrome and Content-Type

Having seen this, one would assume that if you have a resource, say a
User on your system and there were two representations of that
resource - HTML and JSON. Let&rsquo;s assume that the HTML representation does
an AJAX call to fetch the JSON representation and renders it. While this
sounds simple enough, Google Chrome, one of the world&rsquo;s most popular
browsers
totally breaks this. A
good example of this weird behaviour can be seen here.
">
<meta name="twitter:image" content="http://sdqali.in/map[feature:/images/threaded-blue-on-black-cropped.jpg]">

<meta property="og:title" content="On REST, Content-Type, Google Chrome and Caching" />
<meta property="og:description" content="Representational State Transfer (REST) is a style of software
architecture for distributed systems that has replaced technologies like
SOAP as the predominant Web service
design model. Originally proposed by Roy Fielding in his Doctorate
dissertation,
REST puts a lot of emphasis on resources, their representations and states. Basically a URL indicates a
single resource; the HTTP method (GET, POST, PUT, DELETE) indicates what
action should be performed on that resource; and the ACCEPT header indicates the format that the resource should be presented in.

Chrome and Content-Type

Having seen this, one would assume that if you have a resource, say a
User on your system and there were two representations of that
resource - HTML and JSON. Let&rsquo;s assume that the HTML representation does
an AJAX call to fetch the JSON representation and renders it. While this
sounds simple enough, Google Chrome, one of the world&rsquo;s most popular
browsers
totally breaks this. A
good example of this weird behaviour can be seen here.
" itemprop="description"/>
<meta property="og:url" content="http://sdqali.in/blog/2012/11/27/on-rest-content-type-google-chrome-and-caching/" />
<meta property="og:image" content="http://sdqali.in/map[feature:/images/threaded-blue-on-black-cropped.jpg]" />
<body class="theme-base-0b">

<div class="sidebar">
  <div class="container sidebar-sticky">
    <div class="sidebar-about">
      <h1>
	<a href="/">Sadique Ali</a>
      </h1>
      <p class="lead">
       A blog about the Code I write and the Technologies I use. And other things that interest me. 
      </p>
    </div>

    <ul class="sidebar-nav">
      <li><a href="/">Home</a> </li>
      <li><a href="/blog/">Blog</a> </li>
      <li><a href="/about">About</a> </li>
      <li><a href="https://github.com/sdqali">GitHub</a> </li>
      <li><a href="https://twitter.com/sdqali">Twitter</a> </li>
      <li><a href="https://www.linkedin.com/in/sdqali">LinkedIn</a> </li>
      
    </ul>

    <p>&copy; 2015. All rights reserved. </p>
  </div>
</div>


<div class="content container" itemscope itemtype="http://schema.org/BlogPosting">
<meta itemscope itemprop="mainEntityOfPage"  itemType="https://schema.org/WebPage" itemid="http://sdqali.in/blog/2012/11/27/on-rest-content-type-google-chrome-and-caching/"/>
<meta itemprop="datePublished" content="2012-11-27 00:00:00 &#43;0000 UTC"/>
<meta itemprop="dateModified" content="2012-11-27 00:00:00 &#43;0000 UTC"/>

<div class="post">
  <h1 itemprop="headline">On REST, Content-Type, Google Chrome and Caching</h1>
  <div class="author" itemprop="author" itemscope itemtype="https://schema.org/Person">
    By <span itemprop="name">Sadique Ali</span>
  </div>
  <span class="post-date">Tue, Nov 27, 2012</span>
      

<p>Representational State Transfer (REST) is a style of software
architecture for distributed systems that has replaced technologies like
<a href="http://en.wikipedia.org/wiki/SOAP">SOAP</a> as the predominant Web service
design model. Originally proposed by Roy Fielding in his <a href="http://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm">Doctorate
dissertation</a>,
REST puts a lot of emphasis on resources, their representations and states. Basically a URL indicates a
single resource; the HTTP method (GET, POST, PUT, DELETE) indicates what
action should be performed on that resource; and the ACCEPT header indicates the format that the resource should be presented in.</p>

<h2 id="chrome-and-content-type:81ded0c677aedede844b66006f9428ca">Chrome and Content-Type</h2>

<p>Having seen this, one would assume that if you have a resource, say a
<code>User</code> on your system and there were two representations of that
resource - HTML and JSON. Let&rsquo;s assume that the HTML representation does
an AJAX call to fetch the JSON representation and renders it. While this
sounds simple enough, Google Chrome, one of the world&rsquo;s most popular
browsers
<a href="https://code.google.com/p/chromium/issues/detail?id=108766">totally breaks this</a>. A
good example of this weird behaviour can be seen <a href="http://chrome-json-bug.heroku.com/docs">here</a>.</p>

<p>I ran in to this issue while playing around with <a href="http://expressjs.com/">Express JS</a>.
Now, the interesting thing here is that the Chrome developers seem to
have closed the issue without providing any convincing answers or
indicating whether they would fix this.</p>

<h2 id="vary-accept-to-the-rescue:81ded0c677aedede844b66006f9428ca">Vary: Accept to the rescue?</h2>

<p>One of the
<a href="https://code.google.com/p/chromium/issues/detail?id=108766#c6">solutions</a>
suggested in the bug discussion is to use the <code>Vary: Accept</code>
header. According to the
<a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.44">specs</a>,
&ldquo;while the response is fresh, whether a cache is permitted to use the
response to reply to a subsequent request without revalidation&rdquo;. In
other words, specifying <code>Vary: Accept</code> tells the client that if there is
a change in the <code>Accept</code> field, the resource in the cache must
be-revalidated. After trying that out and still having to stare at naked
JSON, I was convinced that telling Chrome to
re-validate the resource was the only way to get around this issue. This
leads us to another interesting bug in Chrome.</p>

<h2 id="chrome-ignores-the-no-cache-directive:81ded0c677aedede844b66006f9428ca">Chrome ignores the no-cache directive</h2>

<p>Reading the specs lead me to the
<a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.9.4">Cache-Control</a>
header. According to the specs, &ldquo;If the no-cache directive does not
specify a field-name, then a cache MUST NOT use the response to satisfy
a subsequent request without successful revalidation with the origin
server.&ldquo;. That is exactly what I wanted.
But setting that header did not change anything, I still had naked JSON
when hitting the back button. This led me to
<a href="https://code.google.com/p/chromium/issues/detail?id=28035">yet another bug</a>
on Chrome. Chrome seems to completely ignore the <code>no-cache</code>
directive. One of the <a href="https://code.google.com/p/chromium/issues/detail?id=28035#c3">suggestions</a> in the discussion was to use the
<code>no-store</code> directive. That seemed to fix the issue.</p>

<p>But the
<a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.9.2">spec</a>
says <code>no-store</code> directive should be used to prevent the client from
caching any sensitive information. What that means is that the client
will never cache the resource.</p>

<p>The end result is that you would end up with a system with lot of end
points that are not cache-able because if you make them cache-able, Google
Chrome will leave your users staring at naked JSON.</p>

<h2 id="possible-solutions:81ded0c677aedede844b66006f9428ca">Possible solutions</h2>

<ul>
<li><p>Use different URLs for different representations. In my case, that
would mean I have <code>/users/sdqali.html</code> and <code>/users/sdqali.json</code> as
URLs for the same resource. This somewhat violates the REST principle.</p></li>

<li><p>Do not cache JSON end points at all. While this would work well for my
small app, this is not an effective solution in the general case.</p></li>
</ul>

</div>
</div>

  </body>
</html>
