<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Code Python on Sadique Ali</title>
    <link>http://localhost:1313/categories/code-python/</link>
    <description>Recent content in Code Python on Sadique Ali</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Mon, 07 Oct 2013 00:00:00 +0000</lastBuildDate>
    <atom:link href="http://localhost:1313/categories/code-python/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Python Hack - Dynamically override an object&#39;s attribute</title>
      <link>http://localhost:1313/blog/2013/10/07/python-hack---dynamically-override-an-objects-attribute/</link>
      <pubDate>Mon, 07 Oct 2013 00:00:00 +0000</pubDate>
      
      <guid>http://localhost:1313/blog/2013/10/07/python-hack---dynamically-override-an-objects-attribute/</guid>
      <description>

&lt;p&gt;While working with Locust &lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:66b6e5fb09b6083bed97b4d7a2981cc2:1&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:66b6e5fb09b6083bed97b4d7a2981cc2:1&#34;&gt;1&lt;/a&gt;&lt;/sup&gt; recently, we ran into a situation where we had to dynamically override an attribute in a class in the Locust library so as to control what value it got assigned. After a lot of scratching our heads and reading the Python documentation, we came across the &lt;code&gt;property&lt;/code&gt; function. We were able to use this to hack together a solution that ensures that every time an attribute is read, it returns the result of executing a method.&lt;/p&gt;

&lt;p&gt;The following example demonstrates a stripped down version of this hack.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import random

class Foo(object):
    bar = random.random()

foo = Foo()

# Prints the value assigned when the Foo object is initialised.
print(&amp;quot;Before override&amp;quot;)
print(foo.bar)
print(foo.bar)

# Override
Foo.bar = property(lambda self: random.random())

print(&amp;quot;After override&amp;quot;)
print(foo.bar)
print(foo.bar)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This snippet when executed will output the following:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Before override
0.0373028550804
0.0373028550804
After override
0.603160033663
0.501455108419
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It can be seen that before introducing the override, the value of the &lt;code&gt;bar&lt;/code&gt; attribute is set when the class is initialised and as expected, it does not change how many ever times the attribute is read. However, after the override, the attribute is assigned a new value every time it is read.&lt;/p&gt;

&lt;h2 id=&#34;how-does-this-work:66b6e5fb09b6083bed97b4d7a2981cc2&#34;&gt;How does this work?&lt;/h2&gt;

&lt;p&gt;The &lt;code&gt;property()&lt;/code&gt; &lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:66b6e5fb09b6083bed97b4d7a2981cc2:2&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:66b6e5fb09b6083bed97b4d7a2981cc2:2&#34;&gt;2&lt;/a&gt;&lt;/sup&gt; function returns an attribute for any class. It allows the creation of Ruby&amp;rsquo;s &lt;code&gt;attr_accessor&lt;/code&gt; &lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:66b6e5fb09b6083bed97b4d7a2981cc2:3&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:66b6e5fb09b6083bed97b4d7a2981cc2:3&#34;&gt;3&lt;/a&gt;&lt;/sup&gt; style attributes on classes so that one can write &lt;code&gt;instance.attrib&lt;/code&gt; to read an attribute value and &lt;code&gt;instance.attrib=&lt;/code&gt; to set an attribute value. What line &lt;code&gt;14&lt;/code&gt; in the snippet does is to re-define the &lt;code&gt;bar&lt;/code&gt; attribute to be a property whose &lt;code&gt;getter&lt;/code&gt; is a &lt;code&gt;lambda&lt;/code&gt;. Every time the &lt;code&gt;bar&lt;/code&gt; attribute is read, the &lt;code&gt;lambda&lt;/code&gt; gets executed.&lt;/p&gt;

&lt;p&gt;A more comprehensive example of this can be found in my &lt;a href=&#34;https://github.com/sdqali/python_dojo/blob/master/dynamic_override/dynamic_override.py&#34;&gt;Python dojo repository&lt;/a&gt; on GitHub.&lt;/p&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:66b6e5fb09b6083bed97b4d7a2981cc2:1&#34;&gt;&lt;a href=&#34;http://locust.io/&#34;&gt;Locust&lt;/a&gt; - a modern load testing framework.
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:66b6e5fb09b6083bed97b4d7a2981cc2:1&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:66b6e5fb09b6083bed97b4d7a2981cc2:2&#34;&gt;Python&amp;rsquo;s built-in functions - &lt;a href=&#34;http://docs.python.org/2/library/functions.html#property&#34;&gt;property&lt;/a&gt;.
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:66b6e5fb09b6083bed97b4d7a2981cc2:2&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:66b6e5fb09b6083bed97b4d7a2981cc2:3&#34;&gt;Ruby&amp;rsquo;s &lt;a href=&#34;http://www.ruby-doc.org/core-1.9.3/Module.html#method-i-attr_accessor&#34;&gt;&lt;code&gt;attr_accessor&lt;/code&gt; method&lt;/a&gt;.
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:66b6e5fb09b6083bed97b4d7a2981cc2:3&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Python&#39;s bool type</title>
      <link>http://localhost:1313/blog/2013/08/15/pythons-bool-type/</link>
      <pubDate>Thu, 15 Aug 2013 00:00:00 +0000</pubDate>
      
      <guid>http://localhost:1313/blog/2013/08/15/pythons-bool-type/</guid>
      <description>&lt;p&gt;Python does not have a true boolean type. The &lt;code&gt;True&lt;/code&gt; and &lt;code&gt;False&lt;/code&gt; built-in values in Python are wrappers around the integers &lt;code&gt;1&lt;/code&gt; and &lt;code&gt;0&lt;/code&gt;. This results in some interesting results involving True and False.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; True == 1
True
&amp;gt;&amp;gt;&amp;gt; False == 0
True
&amp;gt;&amp;gt;&amp;gt; True + 9
10
&amp;gt;&amp;gt;&amp;gt; False - 1
-1
&amp;gt;&amp;gt;&amp;gt; str(True)
&#39;True&#39;
&amp;gt;&amp;gt;&amp;gt; repr(True)
&#39;True&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The Python bool implementation got formalised in PEP 285 &lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:7cccdb5320cc2243dc45bf92318883e6:1&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:7cccdb5320cc2243dc45bf92318883e6:1&#34;&gt;1&lt;/a&gt;&lt;/sup&gt; in 2002 by Guido van Rossum. The specification gives a lot of insight into von Rossum&amp;rsquo;s insistence on maintaining backward compatibility and the Python way. It also touches up on another aspect of truthness in Python. In Python, almost all objects can be used to represent truth values. This means an empty list is false and a non-empty list is true.&lt;/p&gt;

&lt;p&gt;So this&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;if []:
    print &amp;quot;Truth&amp;quot;
else:
    print &amp;quot;Falsehood&amp;quot;

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;will print &amp;ldquo;Falsehood&amp;rdquo; and the following&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;if [1, 2, 3]:
    print &amp;quot;Truth&amp;quot;
else:
    print &amp;quot;Falsehood&amp;quot;

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;will print &amp;ldquo;Truth&amp;rdquo;.&lt;/p&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:7cccdb5320cc2243dc45bf92318883e6:1&#34;&gt;&lt;a href=&#34;http://www.python.org/dev/peps/pep-0285/&#34;&gt;Adding a bool type&lt;/a&gt; by Guido van Rossum.
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:7cccdb5320cc2243dc45bf92318883e6:1&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Understanding Python&#39;s &#34;with&#34; statement</title>
      <link>http://localhost:1313/blog/2012/07/09/understanding-pythons-with-statement/</link>
      <pubDate>Mon, 09 Jul 2012 00:00:00 +0000</pubDate>
      
      <guid>http://localhost:1313/blog/2012/07/09/understanding-pythons-with-statement/</guid>
      <description>

&lt;h2 id=&#34;what-is-it:ac4d2c4b2f71b3b47d24799d64503bb3&#34;&gt;What is it?&lt;/h2&gt;

&lt;p&gt;Python&amp;rsquo;s &lt;code&gt;with&lt;/code&gt; statement provides a very convenient way of dealing with the situation where you have to do a setup and teardown to make something happen. A very good example for this is the situation where you want to gain a handler to a file, read data from the file and the close the file handler.&lt;/p&gt;

&lt;p&gt;Without the &lt;code&gt;with&lt;/code&gt; statement, one would write something along the lines of:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;file = open(&amp;quot;/tmp/foo.txt&amp;quot;)
data = file.read()
file.close()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There are two annoying things here. First, you end up forgetting to close the file handler. The second is how to handle exceptions that may occur once the file handler has been obtained. One could write something like this to get around this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;file = open(&amp;quot;/tmp/foo.txt&amp;quot;)
try:
    data = file.read()
finally:
    file.close()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;While this works well, it is unnecessarily verbose. This is where &lt;code&gt;with&lt;/code&gt; is useful. The good thing about &lt;code&gt;with&lt;/code&gt; apart from the better syntax is that it is very good handling exceptions. The above code would look like this, when using &lt;code&gt;with&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;with open(&amp;quot;/tmp/foo.txt&amp;quot;) as file:
   data = file.read()
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;how-does-it-work:ac4d2c4b2f71b3b47d24799d64503bb3&#34;&gt;How does it work?&lt;/h2&gt;

&lt;p&gt;While this might look like magic, the way Python handles &lt;code&gt;with&lt;/code&gt; is more clever than magic. The basic idea is that the statement after &lt;code&gt;with&lt;/code&gt; has to evaluate an object that responds to an &lt;code&gt;__enter__()&lt;/code&gt; as well as an &lt;code&gt;__exit__()&lt;/code&gt; function.&lt;/p&gt;

&lt;p&gt;After the statement that follows &lt;code&gt;with&lt;/code&gt; is evaluated, the &lt;code&gt;__enter__()&lt;/code&gt; function on the resulting object is called. The value returned by this function is assigned to the variable following &lt;code&gt;as&lt;/code&gt;. After every statement in the block is evaluated, the &lt;code&gt;__exit__()&lt;/code&gt; function is called.&lt;/p&gt;

&lt;p&gt;This can be demonstrated with the following example:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;#!/usr/bin/env python
# with_example01.py


class Sample:
    def __enter__(self):
        print &amp;quot;In __enter__()&amp;quot;
        return &amp;quot;Foo&amp;quot;

    def __exit__(self, type, value, trace):
        print &amp;quot;In __exit__()&amp;quot;


def get_sample():
    return Sample()


with get_sample() as sample:
    print &amp;quot;sample:&amp;quot;, sample
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When executed, this will result in:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;bash-3.2$ ./with_example01.py
In __enter__()
sample: Foo
In __exit__()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As you can see,&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;The &lt;code&gt;__enter__()&lt;/code&gt; function is executed&lt;/li&gt;
&lt;li&gt;The value returned by it - in this case &lt;code&gt;&amp;quot;Foo&amp;quot;&lt;/code&gt; is assigned to &lt;code&gt;sample&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;The body of the block is executed, thereby printing the value of &lt;code&gt;sample&lt;/code&gt; ie. &lt;code&gt;&amp;quot;Foo&amp;quot;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;The &lt;code&gt;__exit__()&lt;/code&gt; function is called.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;What makes &lt;code&gt;with&lt;/code&gt; really powerful is the fact that it can handle exceptions. You would have noticed that the &lt;code&gt;__exit__()&lt;/code&gt; function for &lt;code&gt;Sample&lt;/code&gt; takes three arguments - &lt;code&gt;val&lt;/code&gt;, &lt;code&gt;type&lt;/code&gt; and &lt;code&gt;trace&lt;/code&gt;. These are useful in exception handling. Let&amp;rsquo;s see how this works by modifying the above example.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;#!/usr/bin/env python
# with_example02.py


class Sample:
    def __enter__(self):
        return self

    def __exit__(self, type, value, trace):
        print &amp;quot;type:&amp;quot;, type
        print &amp;quot;value:&amp;quot;, value
        print &amp;quot;trace:&amp;quot;, trace

    def do_something(self):
        bar = 1/0
        return bar + 10

with Sample() as sample:
    sample.do_something()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Notice how in this example, instead of &lt;code&gt;get_sample()&lt;/code&gt;, &lt;code&gt;with&lt;/code&gt; takes &lt;code&gt;Sample()&lt;/code&gt;. It does not matter, as long as the statement that follows &lt;code&gt;with&lt;/code&gt; evaluates to an object that has an &lt;code&gt;__enter__()&lt;/code&gt; and &lt;code&gt;__exit__()&lt;/code&gt; functions. In this case, &lt;code&gt;Sample()&lt;/code&gt;&amp;rsquo;s &lt;code&gt;__enter__()&lt;/code&gt; returns the newly created instance of &lt;code&gt;Sample&lt;/code&gt; and that is what gets passed to &lt;code&gt;sample&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;When executed:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;bash-3.2$ ./with_example02.py
type: &amp;lt;type &#39;exceptions.ZeroDivisionError&#39;&amp;gt;
value: integer division or modulo by zero
trace: &amp;lt;traceback object at 0x1004a8128&amp;gt;
Traceback (most recent call last):
  File &amp;quot;./with_example02.py&amp;quot;, line 19, in &amp;lt;module&amp;gt;
    sample.do_something()
  File &amp;quot;./with_example02.py&amp;quot;, line 15, in do_something
    bar = 1/0
ZeroDivisionError: integer division or modulo by zero
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Essentially, if there are exceptions being thrown from anywhere inside the block, the &lt;code&gt;__exit__()&lt;/code&gt; function for the object is called. As you can see, the type, value and the stack trace associated with the exception thrown is passed to this function. In this case, you can see that there was a &lt;code&gt;ZeroDivisionError&lt;/code&gt; exception being thrown. People implementing libraries can write code that clean up resources, close files etc. in their &lt;code&gt;__exit__()&lt;/code&gt; functions.&lt;/p&gt;

&lt;p&gt;Thus, Python&amp;rsquo;s &lt;code&gt;with&lt;/code&gt; is a nifty construct that makes code a little less verbose and makes cleaning up during exceptions a bit easier.&lt;/p&gt;

&lt;p&gt;I have put the code examples given here on &lt;a href=&#34;https://github.com/sdqali/python_dojo/tree/master/with&#34;&gt;Github&lt;/a&gt;.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Autorun.py - Execute stuff on file change</title>
      <link>http://localhost:1313/blog/2010/01/09/autorun.py---execute-stuff-on-file-change/</link>
      <pubDate>Sat, 09 Jan 2010 00:00:00 +0000</pubDate>
      
      <guid>http://localhost:1313/blog/2010/01/09/autorun.py---execute-stuff-on-file-change/</guid>
      <description>&lt;p&gt;I really liked ZenTest&amp;rsquo;s Autospec in action. Recently, when I was trying to write some Python stuff, I thought it would be nice if I would have a tool that would just run the unit tests, so that I don&amp;rsquo;t have to switch between console windows. Better still, I could run it from inside my Emacs.&lt;/p&gt;

&lt;p&gt;Clearly, monitoring files for changes, shouldn&amp;rsquo;t be big deal. I decided to write the tool myself in Python. the prime intension was to help myself learn Python. Although that didn&amp;rsquo;t quite workout, I managed to come up with a quick and dirty hack to do it. It uses &lt;code&gt;pyinotify&lt;/code&gt;, which is a Python module for monitoring filesystem changes. Since &lt;code&gt;pyinotify&lt;/code&gt; depends on the Linux kernel, this would work only on Linux boxes.&lt;/p&gt;

&lt;p&gt;I named it &lt;code&gt;autorun.py&lt;/code&gt;. If you want to run some task, depending on file changes in a directory, you navigate to that directory and start autorunner as:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;~/src/sdq/ocr$ ./autorun.py &amp;quot;python Test*.py&amp;quot;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;That would start &lt;code&gt;autorun.py&lt;/code&gt; and every time I modify a file in the present directory the command  &lt;code&gt;python Test*.py&lt;/code&gt; is executed. In my case, I am using the unittest framework that comes with Python. So everytime, a file is updates, it runs all my unit tests, as seen below:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;sadiquea@sadiquea-laptop:~/src/sdq/ocr$ ./autorun.py &amp;quot;python Test*.py&amp;quot;
Autorunner in action
.............

----------------------------------------------------------------------

Ran 13 tests in 0.763s

OK
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If I were working with Ruby and wanted to run all my unit tests when I modify the files, I could start the tool like this: &lt;code&gt;./autorun.py &amp;quot;rake spec&amp;quot;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;I would really like to add the ability to exclude some files/subdirectories from being watched for changes.&lt;/p&gt;

&lt;p&gt;Here is the code snippet that does the trick:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;#!/usr/bin/env python

import sys
import os
import pyinotify

if len(sys.argv)==1:
    print &amp;quot;Please pass a command to excute as a parameter&amp;quot;
    print &amp;quot;For example autorun.py &#39;ruby foo.rb&#39;&amp;quot;
    sys.exit()

commandToRun = sys.argv[1]

watchManager = pyinotify.WatchManager()
mask = pyinotify.IN_MODIFY

class ActionProcesser(pyinotify.ProcessEvent):
    def process_IN_MODIFY(self, event):
        print &amp;quot;Autorunner in action&amp;quot;
        os.system(commandToRun)

notifier = pyinotify.Notifier(watchManager, ActionProcesser())

wdd = watchManager.add_watch(os.getcwd(), mask, rec=True)

while True:
    try:
        notifier.process_events()
        if notifier.check_events():
            notifier.read_events()
    except KeyboardInterrupt:
        notifier.stop()
        break

&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
  </channel>
</rss>