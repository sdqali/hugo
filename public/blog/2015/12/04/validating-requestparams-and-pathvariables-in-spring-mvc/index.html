<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en-us">
<head>
  <link href="http://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">

  
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  <title> Validating RequestParams and PathVariables in Spring MVC &middot; Sadique Ali </title>

  
  <link rel="stylesheet" href="http://sdqali.in/css/poole.css">
  <link rel="stylesheet" href="http://sdqali.in/css/syntax.css">
  <link rel="stylesheet" href="http://sdqali.in/css/hyde.css">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=PT+Sans:400,400italic,700|Abril+Fatface">

  
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/apple-touch-icon-144-precomposed.png">
  <link rel="shortcut icon" href="/favicon.ico">

  
  <link href="" rel="alternate" type="application/rss+xml" title="Sadique Ali" />

</head>


<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:site" content="@sdqali">
<meta name="twitter:creator" content="@sdqali">
<meta name="twitter:title" content="Validating RequestParams and PathVariables in Spring MVC">
<meta name="twitter:description" content="Spring MVC provides a convenient way to validate inputs to API end points through the use of JSR-303 annotations. While this mechanism works great for end points that consume a RequestBody (as is the case with most POST and PUT requests), it is not easy to achieve the same effect for end points that consume primitives in the form of path variables or request parameters (as is the case with most GET requests).
">
<meta name="twitter:image" content="http://sdqali.in/">

<body class="theme-base-0b">

<div class="sidebar">
  <div class="container sidebar-sticky">
    <div class="sidebar-about">
      <h1>
	<a href="/">Sadique Ali</a>
      </h1>
      <p class="lead">
       A blog about the Code I write and the Technologies I use. And other things that interest me. 
      </p>
    </div>

    <ul class="sidebar-nav">
      <li><a href="/">Home</a> </li>
      <li><a href="/blog/">Blog</a> </li>
      <li><a href="/about">About</a> </li>
      <li><a href="https://github.com/sdqali">GitHub</a> </li>
      <li><a href="https://twitter.com/sdqali">Twitter</a> </li>
      <li><a href="https://www.linkedin.com/in/sdqali">LinkedIn</a> </li>
      
        <li><a href="/blog/2015/12/06/implementing-custom-annotations-for-spring-mvc/"> Implementing custom annotations for Spring MVC </a></li>
      
    </ul>

    <p>&copy; 2015. All rights reserved. </p>
  </div>
</div>


    <div class="content container">
<div class="post">
  <h1>Validating RequestParams and PathVariables in Spring MVC</h1>
  <span class="post-date">Fri, Dec 4, 2015</span>
      <p>Spring MVC provides a convenient way to validate inputs to API end points through the use of <code>JSR-303</code> annotations. While this mechanism works great for end points that consume a <code>RequestBody</code> (as is the case with most <code>POST</code> and <code>PUT</code> requests), it is not easy to achieve the same effect for end points that consume primitives in the form of path variables or request parameters (as is the case with most <code>GET</code> requests).</p>

<p>Let&rsquo;s take a look at how to validate RequestBody inputs using JSR-303.</p>

<pre><code class="language-java">    @RequestMapping(method = RequestMethod.POST,
            consumes = MediaType.APPLICATION_JSON_VALUE,
            produces = MediaType.APPLICATION_JSON_VALUE
    )
    @ResponseStatus(HttpStatus.OK)
    public Map register(@RequestBody @Valid EmailRequest emailRequest) {
        return registrationService.register(emailRequest);
    }
</code></pre>

<p>The value object <code>EmailRequest</code> is annotated with the appropriate constraint annotations.</p>

<pre><code class="language-java">public class EmailRequest {
    @Email
    public String email;

    private EmailRequest() {
    }

    public String getEmail() {
        return email;
    }
}
</code></pre>

<p>If we were to attempt a similar approach for a <code>GET</code> end point that accepts a <code>RequestParam</code>, the validation would simply not happen.</p>

<pre><code class="language-java">    @RequestMapping(method = RequestMethod.GET,
            consumes = MediaType.APPLICATION_JSON_VALUE,
            produces = MediaType.APPLICATION_JSON_VALUE
    )
    @ResponseStatus(HttpStatus.OK)
    public Map search(@Email
                   @Valid
                   @RequestParam(&quot;email&quot;)
                   String email) {
        return emailMessage(email);
    }
</code></pre>

<p>This is where Spring&rsquo;s <code>@Validated</code> annotation is useful. With <code>@Validated</code>, we can validate request parameters and path variables.</p>

<pre><code class="language-java">@RestController
@Validated
public class RegistrationController {
    @RequestMapping(method = RequestMethod.GET,
            consumes = MediaType.APPLICATION_JSON_VALUE,
            produces = MediaType.APPLICATION_JSON_VALUE
    )
    @ResponseStatus(HttpStatus.OK)
    public Map search(@Email
                   @RequestParam(&quot;email&quot;)
                   String email) {
        return emailMessage(email);
    }
}
</code></pre>

<p>An important thing to note here is that using <code>@Valid</code> annotation results in <code>MethodArgumentNotValidException</code> being thrown when validation fails, but <code>@Validated</code> results in <code>ConstraintViolationException</code> being thrown. Since these exceptions have different ways of abstracting the error messages associated with validation, it is important to have different error handlers for both of these. An example pattern using <code>ExceptionHandler</code> will be as follows:</p>

<pre><code class="language-java">@ControllerAdvice
@Component
public class GlobalExceptionHandler {
    @ExceptionHandler
    @ResponseBody
    @ResponseStatus(HttpStatus.BAD_REQUEST)
    public Map handle(MethodArgumentNotValidException exception) {
        return error(exception.getBindingResult().getFieldErrors()
                .stream()
                .map(FieldError::getDefaultMessage)
                .collect(Collectors.toList()));
    }


    @ExceptionHandler
    @ResponseBody
    @ResponseStatus(HttpStatus.BAD_REQUEST)
    public Map handle(ConstraintViolationException exception) {
        return error(exception.getConstraintViolations()
                .stream()
                .map(ConstraintViolation::getMessage)
                .collect(Collectors.toList()));
    }

    private Map error(Object message) {
        return Collections.singletonMap(&quot;error&quot;, message);
    }
}

</code></pre>

</div>
</div>

  </body>
</html>
