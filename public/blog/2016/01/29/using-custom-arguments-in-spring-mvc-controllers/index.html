<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en-us" prefix="og: http://ogp.me/ns#">
  <head>
    <link href="http://gmpg.org/xfn/11" rel="profile">
    <meta http-equiv="content-type" content="text/html; charset=utf-8">

    
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

    <title> Using custom arguments in Spring MVC controllers &middot; Sadique Ali </title>

    
    <link rel="stylesheet" href="http://sdqali.in/css/poole.css">
    <link rel="stylesheet" href="http://sdqali.in/css/syntax.css">
    <link rel="stylesheet" href="http://sdqali.in/css/hyde.css">
    <link rel="stylesheet" href="http://sdqali.in/css/default.min.css">
    <link rel="stylesheet" href="http://sdqali.in/css/custom.css">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=PT+Sans:400,400italic,700|Abril+Fatface">

    
    <link rel="apple-touch-icon" sizes="57x57" href="/apple-touch-icon-57x57.png">
    <link rel="apple-touch-icon" sizes="60x60" href="/apple-touch-icon-60x60.png">
    <link rel="apple-touch-icon" sizes="72x72" href="/apple-touch-icon-72x72.png">
    <link rel="apple-touch-icon" sizes="76x76" href="/apple-touch-icon-76x76.png">
    <link rel="apple-touch-icon" sizes="114x114" href="/apple-touch-icon-114x114.png">
    <link rel="apple-touch-icon" sizes="120x120" href="/apple-touch-icon-120x120.png">
    <link rel="apple-touch-icon" sizes="144x144" href="/apple-touch-icon-144x144.png">
    <link rel="apple-touch-icon" sizes="152x152" href="/apple-touch-icon-152x152.png">
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon-180x180.png">
    <link rel="icon" type="image/png" href="/favicon-32x32.png" sizes="32x32">
    <link rel="icon" type="image/png" href="/android-chrome-192x192.png" sizes="192x192">
    <link rel="icon" type="image/png" href="/favicon-96x96.png" sizes="96x96">
    <link rel="icon" type="image/png" href="/favicon-16x16.png" sizes="16x16">
    <link rel="manifest" href="/manifest.json">
    <link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">
    <meta name="msapplication-TileColor" content="#da532c">
    <meta name="msapplication-TileImage" content="/mstile-144x144.png">
    <meta name="theme-color" content="#ffffff">

    <script src="https://d26b395fwzu5fz.cloudfront.net/3.3.0/keen.min.js" type="text/javascript"></script>
    <script src="http://sdqali.in/js/parseuri.js" type="text/javascript"></script>
    <script src="http://sdqali.in/js/ua-parser.min.js" type="text/javascript"></script>
    <script src="http://sdqali.in/js/Math.uuid.js" type="text/javascript"></script>

    
    <link href="" rel="alternate" type="application/rss+xml" title="Sadique Ali" />

    <script type="text/javascript" src="http://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.0.0/highlight.min.js"></script>
    <script type="text/javascript">
      hljs.initHighlightingOnLoad();
    </script>

    <script type="text/javascript">
  var client = new Keen({
    projectId: "566f9f7a96773d75e098bb34", 
    writeKey: "5d41bf4e9b86ee088f2ae748d782f6e40501d9f1807e04cd3c2bea52c276f14416f585877c39785704bdd5407aae393cc8ad601646d2112f8293a0269145baebec15f48e073186173b9e6c82cd3767456296c77a46d23b827c82492116d919e8401dfa84c56f13adac91963575522314",   
    readKey: "57d95890c1893e97bb47ff02d5082242490a5f0585777e5f157ff3c5f01aca1c1e5bdaab91d874668b7154981d14dd5d73e3a54ef3360e93f29ea1b50b36b339e0e0fe063347fa6ce9bf9f1536752fa81bf2e12079a21e2e57312a55260403f09915e11455cb98e69a2dc9094c14184a"      
  });

var uri = parseUri(window.location.href);
var referrer = parseUri(document.referrer);
var uaParser = new UAParser();
client.addEvent("pagehit", {
  "url" : {
    "source" : uri.source,
    "protocol" : uri.protocol,
    "domain" : uri.host,
    "port" : uri.port,
    "path" : uri.path,
    "anchor" : uri.anchor
  },
  "user_agent" : {
    "browser" : uaParser.getBrowser(),
    "engine" : uaParser.getEngine(),
    "os" : uaParser.getOS()
  },
  referrer: {
    "source" : referrer.source,
    "protocol" : referrer.protocol,
    "domain" : referrer.host,
    "port" : referrer.port,
    "path" : referrer.path,
    "anchor" : referrer.anchor
  },
  "session_id" : Math.uuid(),
  "permanent_tracker" : Math.uuid()
});
</script>

  </head>


<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:site" content="@sdqali">
<meta name="twitter:creator" content="@sdqali">
<meta name="twitter:title" content="Using custom arguments in Spring MVC controllers">
<meta name="twitter:description" content="Most of the Spring controllers in the real world accept a lot of different types of parameters - Path variables, URL parameters, request headers, request body and sometimes even the entire HTTP Request object. This provides a flexible mechanism to create APIs. Spring is really good at parsing these parameters in to Java types as long as there is an ObjectMapper (like Jackson) configured to take care of the de-serialization.

However, there are situations where you want methods to receive a parameter of a particular type that has to resolved from a set of parameters–for example, an API can expect consumers to send meta data about a request in the form of headers and need a custom type to hold this information. Spring provides a convenient way to provide such custom arguments. This blog post explores this feature and how to implement it and test it.
">
<meta name="twitter:image" content="http://sdqali.in/images/spring-by-pivotal.png">

<meta property="og:title" content="Using custom arguments in Spring MVC controllers" />
<meta property="og:description" content="Most of the Spring controllers in the real world accept a lot of different types of parameters - Path variables, URL parameters, request headers, request body and sometimes even the entire HTTP Request object. This provides a flexible mechanism to create APIs. Spring is really good at parsing these parameters in to Java types as long as there is an ObjectMapper (like Jackson) configured to take care of the de-serialization.

However, there are situations where you want methods to receive a parameter of a particular type that has to resolved from a set of parameters–for example, an API can expect consumers to send meta data about a request in the form of headers and need a custom type to hold this information. Spring provides a convenient way to provide such custom arguments. This blog post explores this feature and how to implement it and test it.
" itemprop="description"/>
<meta property="og:url" content="http://sdqali.in/blog/2016/01/29/using-custom-arguments-in-spring-mvc-controllers/" />
<meta property="og:image" content="http://sdqali.in/images/spring-by-pivotal.png" />
<body class="theme-base-08">

<div class="sidebar">
  <div class="container sidebar-sticky">
    <div class="sidebar-about">
      <h1>
	<a href="/">Sadique Ali</a>
      </h1>
      <p class="lead">
       A blog about the Code I write and the Technologies I use. And other things that interest me. 
      </p>
    </div>

    <ul class="sidebar-nav">
      <li><a href="/">Home</a> </li>
      <li><a href="/blog/">Blog</a> </li>
      <li><a href="/about">About</a> </li>
      <li><a href="https://github.com/sdqali">GitHub</a> </li>
      <li><a href="https://twitter.com/sdqali">Twitter</a> </li>
      <li><a href="https://www.linkedin.com/in/sdqali">LinkedIn</a> </li>
      
    </ul>

    <p>&copy; 2016. All rights reserved. </p>
  </div>
</div>


<div class="content container" itemscope itemtype="http://schema.org/BlogPosting">
<meta itemscope itemprop="mainEntityOfPage"  itemType="https://schema.org/WebPage" itemid="http://sdqali.in/blog/2016/01/29/using-custom-arguments-in-spring-mvc-controllers/"/>
<meta itemprop="datePublished" content="2016-01-29 17:41:49 -0800 PST"/>
<meta itemprop="dateModified" content="2016-01-29 17:41:49 -0800 PST"/>

<div class="post">
  <h1 itemprop="headline">Using custom arguments in Spring MVC controllers</h1>
  <div class="author" itemprop="author" itemscope itemtype="https://schema.org/Person">
    By <span itemprop="name">Sadique Ali</span>
  </div>
  <span class="post-date">Fri, Jan 29, 2016</span>
      

<p>Most of the Spring controllers in the real world accept a lot of different types of parameters - Path variables, URL parameters, request headers, request body and sometimes even the entire HTTP Request object. This provides a flexible mechanism to create APIs. Spring is really good at parsing these parameters in to Java types as long as there is an ObjectMapper (like Jackson) configured to take care of the de-serialization.</p>

<p>However, there are situations where you want methods to receive a parameter of a particular type that has to resolved from a set of parameters–for example, an API can expect consumers to send meta data about a request in the form of headers and need a custom type to hold this information. Spring provides a convenient way to provide such custom arguments. This blog post explores this feature and how to implement it and test it.</p>

<h2 id="argument-resolvers:9aea8f8b4af2f94f2baa143b388c0ef4">Argument Resolvers</h2>

<p>Spring uses argument resolvers to determine how to parse a particular argument required by a controller method from HTTP request body, the URL, URL parameters and HTTP headers. For example when a method expects a request header as in the following example, Spring uses a particular resolver named <code>RequestHeaderMethodArgumentResolver</code> to resolve this argument. All argument resolvers implement the <code>HandlerMethodArgumentResolver</code> interface whose contract is:</p>

<pre><code class="language-java">public interface HandlerMethodArgumentResolver {
    boolean supportsParameter(MethodParameter parameter);
    Object resolveArgument(MethodParameter parameter, ModelAndViewContainer mavContainer,
            NativeWebRequest webRequest, WebDataBinderFactory binderFactory) throws Exception;
}
</code></pre>

<p>The <code>supportsParameter</code> method determines if this resolver is capable of parsing a given parameter and <code>resolveArgument</code> specifies how it‘s value should be computed. Notice how this method has the web <code>NativeWebRequest</code> argument passed to it to allow the look up of request parameters like body, url and headers.</p>

<p>For this example, the MetaData that we are interested in can be represented as a type:</p>

<pre><code class="language-java">public class MetaData {
    @JsonProperty(&quot;data&quot;)
    private Map&lt;String, String&gt; map  = new HashMap&lt;&gt;();

    private MetaData() {
    }

    public MetaData(Map&lt;String, String&gt; map) {
        this.map = map;
    }

    public String get(String key) {
        return map.get(key);
    }
}
</code></pre>

<p>An argument resolver to compute this from the incoming request can be written as follows:</p>

<pre><code class="language-java">public class MetaDataResolver implements HandlerMethodArgumentResolver {
    private static final String TRANSACTION_ID = &quot;TRANSACTION-ID&quot;;
    private static final String ACCESS_KEY = &quot;ACCESS-KEY&quot;;
    private List&lt;String&gt; metaDataHeaderNames = Arrays.asList(TRANSACTION_ID, ACCESS_KEY);

    @Override
    public boolean supportsParameter(MethodParameter parameter) {
        return parameter.getParameterType().equals(MetaData.class);
    }

    @Override
    public Object resolveArgument(MethodParameter parameter, ModelAndViewContainer mavContainer, NativeWebRequest webRequest, WebDataBinderFactory binderFactory) throws Exception {
        HashMap&lt;String, String&gt; map = new HashMap&lt;&gt;();
        metaDataHeaderNames.forEach(name -&gt; {
            if (webRequest.getHeader(name) != null) {
                map.put(name, webRequest.getHeader(name));
            }
        });
        return new MetaData(map);
    }
}
</code></pre>

<p>This resolver will try and compute the value for the argument if the arguments type is <code>MetaData</code>. It computes it by extracting all the headers representing the meta data from the request.</p>

<h2 id="using-in-a-controller-method:9aea8f8b4af2f94f2baa143b388c0ef4">Using in a controller method</h2>

<p>This parameter can be accessed in a controller method as follows:</p>

<pre><code class="language-java">@RestController
@RequestMapping(&quot;/profiles&quot;)
public class ProfileController {
    @Autowired
    ProfileService profileService;

    @RequestMapping(path = &quot;/&quot;,
    method = RequestMethod.POST)
    public Map&lt;String, String&gt; create(@RequestBody Profile profile, MetaData metaData) {
        profileService.create(profile, metaData);
        System.out.printf(metaData.toString());
        return Collections.singletonMap(&quot;message&quot;, &quot;success&quot;);
    }
}
</code></pre>

<p>If we were to run this app and make a request with the following headers, we will see that the MetaData instance did not get constructed with the right parameters.</p>

<h2 id="wiring-up-the-custom-resolver:9aea8f8b4af2f94f2baa143b388c0ef4">Wiring up the custom resolver</h2>

<p>For this resolver to work, it needs to be added to the chain of resolvers that Spring uses. This can be done by extending <code>WebMvcConfigurerAdapter</code>‘s <code>addArgumentResolvers</code> method as follows:</p>

<pre><code class="language-java">@Configuration
public class Config extends WebMvcConfigurerAdapter {
    @Override
    public void addArgumentResolvers(List&lt;HandlerMethodArgumentResolver&gt; argumentResolvers) {
        argumentResolvers.add(new MetaDataResolver());
    }
}
</code></pre>

<h2 id="testing-using-mockmvc:9aea8f8b4af2f94f2baa143b388c0ef4">Testing using MockMvc</h2>

<p>In order to test the behavior of a controller in the presence of a custom argument resolver using MockMvc, the resolver need to be added to the list of resolvers that MockMvc is going to use.
 An example test for the above class is as follows:</p>

<pre><code class="language-java">@RunWith(MockitoJUnitRunner.class)
public class ProfileControllerTest extends TestCase {

    private ProfileController profileController;
    private MockMvc mockMvc;
    private ObjectMapper objectMapper;

    @Mock
    private ProfileService profileService;

    @Before
    public void setUp() {
        objectMapper = new ObjectMapper();
        profileController = new ProfileController(profileService);
        mockMvc = MockMvcBuilders
                .standaloneSetup(profileController)
                .setCustomArgumentResolvers(new MetaDataResolver())
                .build();
    }

    @Test
    public void shouldCreateAProfile() throws Exception {
        Profile profile = new Profile(&quot;foo&quot;, &quot;foo@bar.com&quot;);
        MetaData metaData = new MetaData(Collections.singletonMap(&quot;TRANSACTION-ID&quot;, &quot;foo&quot;));

        mockMvc.perform(post(&quot;/profiles/&quot;)
                .content(objectMapper.writeValueAsBytes(profile))
                .contentType(MediaType.APPLICATION_JSON)
                .header(&quot;TRANSACTION-ID&quot;, &quot;foo&quot;))
                .andExpect(status().isOk());
        Mockito.verify(profileService).create(eq(profile), eq(metaData));
    }
}
</code></pre>

<p>This test is self-explanatory–we wire up the argument resolver, make a request with one of the meta data headers and expect the profile service to be invoked with the right parameters.</p>

</div>
</div>

  </body>
</html>
