<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>{code that works}</title>
    <link>https://sdqali.in/tags/best-practices/index.xml?utm_source=site&amp;utm_medium=feed</link>
    <description>Recent content on {code that works}</description>
    <generator>Hugo -- gohugo.io</generator>
    <atom:link href="/tags/best-practices/index.xml?utm_source=site&amp;utm_medium=feed" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Bullet proof Jenkins setup</title>
      <link>https://sdqali.in/blog/2012/02/03/bullet-proof-jenkins-setup/?utm_source=site&amp;utm_medium=feed</link>
      <pubDate>Fri, 03 Feb 2012 00:00:00 +0000</pubDate>
      
      <guid>https://sdqali.in/blog/2012/02/03/bullet-proof-jenkins-setup/?utm_source=site&amp;utm_medium=feed</guid>
      <description>&lt;div class=&#39;post&#39;&gt;
&lt;div&gt;&lt;div dir=&#34;ltr&#34; style=&#34;text-align: left;&#34; trbidi=&#34;on&#34;&gt;&lt;div&gt;In this
      post, I will describe how a neat setup and some discipline will
      ensure a Jenkins that can be rolled back and recreated very easily
      - a bullet proof Jenkins setup.&lt;br /&gt;&lt;br /&gt;I have been working on
      configuring our Jenkins instance. This was the first time I had
      played around with Jenkins. I am fairly comfortable
      with &lt;a href=&#34;http://www.thoughtworks-studios.com/go-agile-release-management&#34;
              target=&#34;_blank&#34;&gt;Go&lt;/a&gt; from ThoughtWorks Studios. All of
      my past teams used Go as their tool for continuous
      delivery.&lt;br /&gt;&lt;br /&gt;One of the things I found very different from
      Go in Jenkins is the absence of the notion of a Pipeline as the
      basic entity of build, as proposed
      in &lt;a href=&#34;http://continuousdelivery.com/&#34;
            target=&#34;_blank&#34;&gt;Continuous Delivery&lt;/a&gt;. Although there are
      plugins to make this available in Jenkins, we decided to go with
      Jenkins&#39; model of Jobs.&lt;br /&gt;&lt;br /&gt;Another difference I spotted is
      that when a custom task is defined as part of a Job, Jenkins
      creates a shell script with all the steps while executing the
      Job. In Go, each of the steps will have to be defined as a custom
      command.&lt;br /&gt;&lt;br /&gt;We wanted to ensure that our Jenkins
      configuration is version controlled. While this is a huge win, one
      of the ways this situation deteriorates is when a large number of
      changes are made to the configuration over a period of time and
      these is not checked in. So we decided to take this one step
      further and ensure that these changes are automatically checked
      in. There are instructions on how to do this, but we had to do
      some tweaking to get this working for us.

&lt;!--more--&gt;

These are the steps to setup a bullet proof Jenkins setup. This assumes that Jenkins is running on a Linux box.&lt;br /&gt;&lt;br /&gt;1. Create a Git repository in Jenkins&#39; base directory - This is generally &lt;i&gt;/var/lib/jenkins&lt;/i&gt;&lt;br /&gt;2.&amp;nbsp;Create a&amp;nbsp;&lt;i&gt;.gitignore&lt;/i&gt;&amp;nbsp;file to exclude Jenkins workspaces.&amp;nbsp;The Jenkins base directory is the home directory for the Jenkins user created to run Jenkins. This means that there will be a number of&amp;nbsp;Linux user specific files like&amp;nbsp;&lt;i&gt;.ssh/ , .gem&lt;/i&gt;&amp;nbsp;etc.&amp;nbsp;&amp;nbsp;&amp;nbsp;These files need to be specified in the .gitignore file. A sample .gitignore file is listed below.&lt;br /&gt;&lt;br /&gt;&lt;script src=&#34;https://gist.github.com/1732836.js?file=.gitignore&#34;&gt;&lt;/script&gt;&lt;br /&gt;3. Setup a Jenkins job to check in the changed configuration files every day at midnight. (Or whatever time interval you choose). Add a custom task with the following steps:&lt;br /&gt;&lt;br /&gt;&lt;script src=&#34;https://gist.github.com/1732873.js?file=gistfile1.sh&#34;&gt;&lt;/script&gt;&lt;br /&gt;While this ensures that the configuration is more or less tracked well, there are times when somebody makes a massive change in the configuration. This is where the most important piece of the bullet proof configuration comes in - team discipline. The team should ensure that big changes are checked in as soon add possible. This can be easily done by triggering the Jenkins job manually, without having to ssh in to the Jenkins box.&lt;br /&gt;&lt;br /&gt;&lt;b&gt;Credits:&lt;/b&gt;&lt;br /&gt;1.  The Jenkins community documentation provided a nice &lt;a href=&#34;http://jenkins-ci.org/content/keeping-your-configuration-and-data-subversion&#34; target=&#34;_blank&#34;&gt;starting point&lt;/a&gt; for this.&lt;br /&gt;2.  The .gitignore file was forked from &lt;a href=&#34;https://gist.github.com/780105&#34; target=&#34;_blank&#34;&gt;this gist&lt;/a&gt; by &lt;a href=&#34;https://github.com/sit&#34; target=&#34;_blank&#34;&gt;&lt;span id=&#34;goog_1138400375&#34;&gt;&lt;/span&gt;sit&lt;/a&gt;. I have added some project specific stuff to it.&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Why your project should have a Getting Started guide.</title>
      <link>https://sdqali.in/blog/2012/01/17/why-your-project-should-have-a-getting-started-guide./?utm_source=site&amp;utm_medium=feed</link>
      <pubDate>Tue, 17 Jan 2012 00:00:00 +0000</pubDate>
      
      <guid>https://sdqali.in/blog/2012/01/17/why-your-project-should-have-a-getting-started-guide./?utm_source=site&amp;utm_medium=feed</guid>
      <description>&lt;div class=&#39;post&#39;&gt;
&lt;div&gt;&lt;p&gt;My new team at work is writing a bunch of Rails applications. This is one of those codebases that one would call &#34;legacy&#34; without much argument. Most of these apps have their own patched, vendorized Rails versions.&lt;/p&gt;&lt;p&gt;Getting up and running was an absolute pain. This project existed before Bundler and the list of gem dependencies are not checked in. I got the output of running &lt;i&gt;&lt;b&gt;gem list&lt;/b&gt;&lt;/i&gt; on a colleague&#39;s box, wrote a Ruby script to generate a shell script that installs all the gems. When I tried running the tests in one of those apps, I got a nice error. &lt;/p&gt;&lt;p&gt;It looked obvious that we were using patched Rails versions. Surprisingly, theses were not checked in to the vendor/ directory. This was proving to be a pain, and today I sat with a team member and wrote a developer guide to get started on the project. We actually had to pull patched Rails tar balls from a remote box and untar them to vendor/ directory. I was really surprised that these patches had not been checked in. We checked in all the patches. Apart from the Rails patches, there was a gem that had to be checked in.&lt;/p&gt;&lt;p&gt;This is why I think every project needs a Getting Started guide:&lt;br&gt;1. As a developer joining a new team, I want to look at the code as soon as I can. For me, this involves reading and running the tests.&lt;br&gt;2. Due to various reasons, a project may have patches and dependencies. Being very specific to the project, there is no way a new developer on the team would figure out these hidden dependencies.&lt;br&gt;3. There needs to be a single place where all the dependencies are specified.&lt;br&gt;4. While spoon-feeding someone may not be the best way to get them started, a little bit of hand-holding will not do anyone any harm. &lt;/p&gt;&lt;p&gt;One of the biggest problems I see with things like these guides is that as the application and it&#39;s dependencies evolve, the guides are not updated to reflect these changes. The only possible time the guide will be updated is when a new developer joins the team, follows these instructions and finds the need to update the guide.&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;
</description>
    </item>
    
  </channel>
</rss>
