<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Rails on {code that works}</title>
    <link>https://sdqali.in/tags/rails/</link>
    <description>Recent content in Rails on {code that works}</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Sun, 13 Oct 2013 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://sdqali.in/tags/rails/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Implementing Rate Limiting in Rails - Part 2</title>
      <link>https://sdqali.in/blog/2013/10/13/implementing-rate-limiting-in-rails-part-2/</link>
      <pubDate>Sun, 13 Oct 2013 00:00:00 +0000</pubDate>
      
      <guid>https://sdqali.in/blog/2013/10/13/implementing-rate-limiting-in-rails-part-2/</guid>
      <description>The first part of this series can be found here.
The first part of this series looked at how to implement basic rate limiting in a Rails application. However, as pointed out in the improvements section, the implementation was not complete - it did not provide clients enough information about the rate limiting that is in place and how long they should wait before making further requests once they hit the limit.</description>
    </item>
    
    <item>
      <title>Implementing Rate Limiting in Rails - Part 1</title>
      <link>https://sdqali.in/blog/2013/10/12/implementing-rate-limiting-in-rails-part-1/</link>
      <pubDate>Sat, 12 Oct 2013 00:00:00 +0000</pubDate>
      
      <guid>https://sdqali.in/blog/2013/10/12/implementing-rate-limiting-in-rails-part-1/</guid>
      <description>The second part of this series can be found here.
Rate limiting or throttling is the practice of limiting how frequently legitimate users of a web service can access the service. Rate limiting is often put in place to prevent the hogging of resources by a sub set of the users of the system. Rate limiting works by responding with error messages when a client exceeds their allocated share of requests within a predefined time window.</description>
    </item>
    
    <item>
      <title>Why your project should have a Getting Started guide.</title>
      <link>https://sdqali.in/blog/2012/01/17/why-your-project-should-have-a-getting-started-guide./</link>
      <pubDate>Tue, 17 Jan 2012 00:00:00 +0000</pubDate>
      
      <guid>https://sdqali.in/blog/2012/01/17/why-your-project-should-have-a-getting-started-guide./</guid>
      <description>My new team at work is writing a bunch of Rails applications. This is one of those codebases that one would call &#34;legacy&#34; without much argument. Most of these apps have their own patched, vendorized Rails versions.
Getting up and running was an absolute pain. This project existed before Bundler and the list of gem dependencies are not checked in. I got the output of running gem list on a colleague&#39;s box, wrote a Ruby script to generate a shell script that installs all the gems.</description>
    </item>
    
    <item>
      <title>Debugging: C Sharp&#39;s HttpWebRequest, 100-Continue and nginx</title>
      <link>https://sdqali.in/blog/2012/01/16/debugging-c-sharps-httpwebrequest-100-continue-and-nginx/</link>
      <pubDate>Mon, 16 Jan 2012 00:00:00 +0000</pubDate>
      
      <guid>https://sdqali.in/blog/2012/01/16/debugging-c-sharps-httpwebrequest-100-continue-and-nginx/</guid>
      <description>Recently I spent some time debugging an issue our team was facing around some C# code making a request on one of our servers. The request was throwing a &#34;The server committed a protocol violation. Section=ResponseStatusLine&#34; error.
Initial investigation suggested that this could happen if we are making HTTP/1.1 requests to a server configured for HTTP/1.0. Our Rails application runs on Mongrel fronted with nginx 0.6.5. We modified the C# code to use HTTP/1.</description>
    </item>
    
  </channel>
</rss>